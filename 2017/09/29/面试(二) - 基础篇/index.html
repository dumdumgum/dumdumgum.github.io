<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="category 和 extension 的区别• category ：分类有名字，类扩展没i有分类名字，是一种特殊的分类 • extension ：分类只能扩展方法（属性仅仅是声明，并没真正实现），类扩展可以扩展属性、成员变量和方法 define 和 const常量有什么区别?• define在预处理阶段进行替换，const常量在编译阶段使用 • 宏不做类型检查，仅仅进行替换，const常量有数">
<meta property="og:type" content="article">
<meta property="og:title" content="面试2：基础篇">
<meta property="og:url" content="http://yoursite.com/2017/09/29/面试(二) - 基础篇/index.html">
<meta property="og:site_name" content="dumdum&#39;s Blog&#39;">
<meta property="og:description" content="category 和 extension 的区别• category ：分类有名字，类扩展没i有分类名字，是一种特殊的分类 • extension ：分类只能扩展方法（属性仅仅是声明，并没真正实现），类扩展可以扩展属性、成员变量和方法 define 和 const常量有什么区别?• define在预处理阶段进行替换，const常量在编译阶段使用 • 宏不做类型检查，仅仅进行替换，const常量有数">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-09-29T09:34:13.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面试2：基础篇">
<meta name="twitter:description" content="category 和 extension 的区别• category ：分类有名字，类扩展没i有分类名字，是一种特殊的分类 • extension ：分类只能扩展方法（属性仅仅是声明，并没真正实现），类扩展可以扩展属性、成员变量和方法 define 和 const常量有什么区别?• define在预处理阶段进行替换，const常量在编译阶段使用 • 宏不做类型检查，仅仅进行替换，const常量有数">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/09/29/面试(二) - 基础篇/"/>





  <title>面试2：基础篇 | dumdum's Blog'</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">dumdum's Blog'</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/29/面试(二) - 基础篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dumdum's Blog'">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">面试2：基础篇</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-29T17:29:40+08:00">
                2017-09-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="category-和-extension-的区别"><a href="#category-和-extension-的区别" class="headerlink" title="category 和 extension 的区别"></a>category 和 extension 的区别</h2><p>• category ：分类有名字，类扩展没i有分类名字，是一种特殊的分类</p>
<p>• extension ：分类只能扩展方法（属性仅仅是声明，并没真正实现），类扩展可以扩展属性、成员变量和方法</p>
<h2 id="define-和-const常量有什么区别"><a href="#define-和-const常量有什么区别" class="headerlink" title="define 和 const常量有什么区别?"></a>define 和 const常量有什么区别?</h2><p>• define在预处理阶段进行替换，const常量在编译阶段使用</p>
<p>• 宏不做类型检查，仅仅进行替换，const常量有数据类型，会执行类型检查</p>
<p>• define不能调试，const常量可以调试</p>
<p>• define定义的常量在替换后运行过程中会不断地占用内存，而const定义的常量存储在数据段只有一份copy，效率更高</p>
<p>• define可以定义一些简单的函数，const不可以</p>
<h2 id="block和weak修饰符的区别？"><a href="#block和weak修饰符的区别？" class="headerlink" title="block和weak修饰符的区别？"></a>block和weak修饰符的区别？</h2><p>• __block不管是ARC还是MRC模式下都可以使用，可以修饰对象，也可以修饰基本数据类型</p>
<p>• __weak只能在ARC模式下使用，只能修饰对象（NSString），不能修饰基本数据类型</p>
<p>• block修饰的对象可以在block中被重新赋值，weak修饰的对象不可以</p>
<h2 id="static关键字的作用"><a href="#static关键字的作用" class="headerlink" title="static关键字的作用"></a>static关键字的作用</h2><p>• 函数（方法）体内 static 变量的作用范围为该函数体，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；</p>
<p>• 在模块内的 static 全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；</p>
<p>• 在模块内的 static 函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明 它的模块内；</p>
<p>• 在类中的 static 成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；</p>
<p>• 在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能访问类的static 成员变量</p>
<h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><p>• 从管理方式来讲</p>
<p>○ 对于栈来讲，是由编译器自动管理，无需我们手工控制；</p>
<p>○ 对于堆来说，释放工作由程序员控制，容易产生内存泄露(memory leak)</p>
<p>• 从申请大小大小方面讲</p>
<p>○ 栈空间比较小</p>
<p>○ 堆控件比较大</p>
<p>• 从数据存储方面来讲</p>
<p>○ 栈空间中一般存储基本类型，对象的地址</p>
<p>○ 堆空间一般存放对象本身，block的copy等</p>
<h2 id="Objective-C使用什么机制管理对象内存？"><a href="#Objective-C使用什么机制管理对象内存？" class="headerlink" title="Objective-C使用什么机制管理对象内存？"></a>Objective-C使用什么机制管理对象内存？</h2><p>• MRC 手动引用计数</p>
<p>• ARC 自动引用计数,现在通常ARC</p>
<p>• 通过retainCount 的机制来决定对象是否需要释放。 每次 runloop 的时候，都会检查对象的 retainCount，如果retainCount 为 0，说明该对象没有地方需要继续使用了，可以释放掉了</p>
<h2 id="ARC通过什么方式帮助开发者管理内存？"><a href="#ARC通过什么方式帮助开发者管理内存？" class="headerlink" title="ARC通过什么方式帮助开发者管理内存？"></a>ARC通过什么方式帮助开发者管理内存？</h2><p>• 通过编译器在编译的时候,插入类似内存管理的代码</p>
<p>ARC是为了解决什么问题诞生的？</p>
<p>• 首先解释ARC: automatic reference counting自动引用计数</p>
<p>• 了解MRC的缺点</p>
<p>○ 在MRC时代当我们要释放一个堆内存时，首先要确定指向这个堆空间的指针都被release了</p>
<p>○ 释放指针指向的堆空间，首先要确定哪些指针指向同一个堆，这些指针只能释放一次(MRC下即谁创建，谁释放，避免重复释放)</p>
<p>○ 模块化操作时，对象可能被多个模块创建和使用，不能确定最后由谁去释放</p>
<p>○ 多线程操作时，不确定哪个线程最后使用完毕</p>
<p>• 综上所述，MRC有诸多缺点，很容易造成内存泄露和坏内存的问题，这时苹果为尽量解决这个问题，从而诞生了ARC</p>
<h2 id="ARC下还会存在内存泄露吗？"><a href="#ARC下还会存在内存泄露吗？" class="headerlink" title="ARC下还会存在内存泄露吗？"></a>ARC下还会存在内存泄露吗？</h2><p>• 循环引用会导致内存泄露</p>
<p>• Objective-C对象与CoreFoundation对象进行桥接的时候如果管理不当也会造成内存泄露</p>
<p>• CoreFoundation中的对象不受ARC管理，需要开发者手动释放</p>
<h2 id="什么情况使用weak关键字，相比assign有什么不同？"><a href="#什么情况使用weak关键字，相比assign有什么不同？" class="headerlink" title="什么情况使用weak关键字，相比assign有什么不同？"></a>什么情况使用weak关键字，相比assign有什么不同？</h2><p>• 首先明白什么情况使用weak关键字？</p>
<p>○ 在ARC中,在有可能出现循环引用的时候,往往要通过让其中一端使用weak来解决,比如:delegate代理属性，代理属性也可使用assign</p>
<p>○ 自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用weak,自定义IBOutlet控件属性一般也使用weak；当然，也可以使用strong，但是建议使用weak</p>
<p>• weak 和assign的不同点</p>
<p>○ weak策略在属性所指的对象遭到摧毁时，系统会将weak修饰的属性对象的指针指向nil，在OC给nil发消息是不会有什么问题的；如果使用assign策略在属性所指的对象遭到摧毁时，属性对象指针还指向原来的对象，由于对象已经被销毁，这时候就产生了野指针，如果这时候在给此对象发送消息，很容造成程序奔溃</p>
<p>○ assigin 可以用于修饰非OC对象,而weak必须用于OC对象</p>
<h2 id="property-的本质是什么？"><a href="#property-的本质是什么？" class="headerlink" title="@property 的本质是什么？"></a>@property 的本质是什么？</h2><p>• @property其实就是在编译阶段由编译器自动帮我们生成ivar成员变量，getter方法，setter方法</p>
<p>ivar、getter、setter是如何生成并添加到这个类中的？</p>
<p>• 使用“自动合成”( autosynthesis)</p>
<p>• 这个过程由编译器在编译阶段执行自动合成，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码</p>
<p>• 除了生成getter、setter方法之外，编译器还要自动向类中添加成员变量（在属性名前面加下划线，以此作为实例变量的名字）</p>
<h2 id="protocol-和-category-中如何使用-property"><a href="#protocol-和-category-中如何使用-property" class="headerlink" title="@protocol 和 category 中如何使用 @property"></a>@protocol 和 category 中如何使用 @property</h2><p>• 在protocol中使用property只会生成setter和getter方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性</p>
<p>• category 使用 @property也是只会生成setter和getter方法声明,如果我们真的需要给category增加属性的实现,需要借助于运行时的两个函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">objc_setAssociatedObject</div><div class="line">objc_getAssociatedObject</div></pre></td></tr></table></figure>
<h2 id="property后面可以有哪些修饰符？"><a href="#property后面可以有哪些修饰符？" class="headerlink" title="@property后面可以有哪些修饰符？"></a>@property后面可以有哪些修饰符？</h2><p>• 原子性—nonatomic特质</p>
<p>○ 如果不写默认情况为atomic（系统会自动加上同步锁，影响性能）</p>
<p>○ 在iOS开发中尽量指定为nonatomic，这样有助于提高程序的性能</p>
<p>• 读/写权限—readwrite(读写)、readooly (只读)</p>
<p>• 内存管理语义—assign、strong、 weak、unsafe_unretained、copy</p>
<p>• 方法名—getter=、setter=</p>
<p>@property (nonatomic, getter=isOn) BOOL on;</p>
<p>• 不常用的：nonnull,null_resettable,nullable</p>
<h2 id="使用atomic一定是线程安全的吗？"><a href="#使用atomic一定是线程安全的吗？" class="headerlink" title="使用atomic一定是线程安全的吗？"></a>使用atomic一定是线程安全的吗？</h2><p>• 不是，atomic的本意是指属性的存取方法是线程安全的，并不保证整个对象是线程安全的。</p>
<p>• 举例：声明一个NSMutableArray的原子属性stuff，此时self.stuff 和self.stuff = othersulf都是线程安全的。但是，使用[self.stuff objectAtIndex:index]就不是线程安全的，需要用互斥锁来保证线程安全性</p>
<h2 id="synthesize-和-dynamic分别有什么作用"><a href="#synthesize-和-dynamic分别有什么作用" class="headerlink" title="@synthesize 和 @dynamic分别有什么作用"></a>@synthesize 和 @dynamic分别有什么作用</h2><p>• @property有两个对应的词，一个是@synthesize，一个是@dynamic。如果@synthesize和@dynamic都没写，那么默认的就是@syntheszie var = _var;</p>
<p>• @synthesize的语义是如果你没有手动实现setter方法和getter方法，那么编译器会自动为你加上这两个方法</p>
<p>• @dynamic告诉编译器：属性的setter与getter方法由用户自己实现，不自动生成（当然对于readonly的属性只需提供getter即可）</p>
<p>○ 假如一个属性被声明为@dynamic var，然后你没有提供@setter方法和@getter方法，编译的时候没问题，但是当程序运行到instance.var = someVar，由于缺setter方法会导致程序崩溃；或者当运行到 someVar = instance.var时，由于缺getter方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定</p>
<h2 id="ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？"><a href="#ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？" class="headerlink" title="ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？"></a>ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</h2><p>• 基本数据：atomic,readwrite,assign</p>
<p>• 普通的OC对象：atomic,readwrite,strong</p>
<h2 id="怎么用-copy-关键字？"><a href="#怎么用-copy-关键字？" class="headerlink" title="怎么用 copy 关键字？"></a>怎么用 copy 关键字？</h2><p>• NSString、NSArray、NSDictionary等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，为确保对象中的属性值不会无意间变动，应该在设置新属性值时拷贝一份，保护其封装性</p>
<p>• block也经常使用copy关键字</p>
<p>○ block 使用copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.</p>
<p>○ 在ARC中写不写都行：对于 block 使用 copy 还是 strong 效果是一样的，但是建议写上copy，因为这样显示告知调用者“编译器会自动对 block 进行了 copy 操作”</p>
<h2 id="用-property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？"><a href="#用-property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？" class="headerlink" title="用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？"></a>用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</h2><p>• 因为父类指针可以指向子类对象,使用copy的目的是为了让本对象的属性不受外界影响,使用copy无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.</p>
<p>• 如果我们使用是strong,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性.</p>
<h2 id="void-load-void-initialize-有什么用处？"><a href="#void-load-void-initialize-有什么用处？" class="headerlink" title="+(void)load; +(void)initialize;有什么用处？"></a>+(void)load; +(void)initialize;有什么用处？</h2><p>• +(void)load;</p>
<p>○ 当类对象被引入项目时, runtime会向每一个类对象发送 load 消息</p>
<p>○ load 方法会在每一个类甚至分类被引入时仅调用一次,调用的顺序：父类优先于子类, 子类优先于分类</p>
<p>○ 由于load 方法会在类被import 时调用一次,而这时往往是改变类的行为的最佳时机，在这里可以使用例如method swizlling 来修改原有的方法</p>
<p>○ load 方法不会被类自动继承</p>
<p>• +(void)initialize;</p>
<p>○ 也是在第一次使用这个类的时候会调用这个方法，也就是说 initialize也是懒加载</p>
<h2 id="KVO内部实现原理"><a href="#KVO内部实现原理" class="headerlink" title="KVO内部实现原理"></a>KVO内部实现原理</h2><p>• KVO是基于runtime机制实现的</p>
<p>• 当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter 方法。派生类在被重写的setter方法内实现真正的通知机制</p>
<p>• 如果原类为Person，那么生成的派生类名为NSKVONotifying_Person</p>
<p>• 每个类对象中都有一个isa指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将isa指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的setter方法</p>
<p>• 键值观察通知依赖于NSObject 的两个方法: willChangeValueForKey: 和didChangevlueForKey:；在一个被观察属性发生改变之前， willChangeValueForKey: 一定会被调用，这就 会记录旧的值。而当改变发生后，didChangeValueForKey: 会被调用，继而observeValueForKey:ofObject:change:context: 也会被调用。</p>
<p>• 补充：KVO的这套实现机制中苹果还偷偷重写了class方法，让我们误认为还是使用的当前类，从而达到隐藏生成的派生类</p>
<p>如何手动触发一个value的KVO<br>• 自动触发的场景：在注册KVO之前设置一个初始值，注册之后，设置一个不一样的值，就可以触发了<br>• 想知道如何手动触发，必须知道自动触发 KVO 的原理，见上面的描述<br>• 手动触发演示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong) NSDate *now;</div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    “手动触发self.now的KVO”，必写。</div><div class="line">    [self willChangeValueForKey:@&quot;now&quot;];</div><div class="line">    “手动触发self.now的KVO”，必写。</div><div class="line">    [self didChangeValueForKey:@&quot;now&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>若一个类有实例变量NSString *_foo，调用setValue:forKey:时，是以foo还是_foo作为key？<br>• 都可以</p>
<blockquote>
<p>有什么问题都可联系我们 ：dumdumgum@163.com</p>
</blockquote>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/09/29/面试  (一) - 基础篇/" rel="next" title="面试1：基础篇">
                <i class="fa fa-chevron-left"></i> 面试1：基础篇
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#category-和-extension-的区别"><span class="nav-number">1.</span> <span class="nav-text">category 和 extension 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#define-和-const常量有什么区别"><span class="nav-number">2.</span> <span class="nav-text">define 和 const常量有什么区别?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#block和weak修饰符的区别？"><span class="nav-number">3.</span> <span class="nav-text">block和weak修饰符的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static关键字的作用"><span class="nav-number">4.</span> <span class="nav-text">static关键字的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆和栈的区别"><span class="nav-number">5.</span> <span class="nav-text">堆和栈的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Objective-C使用什么机制管理对象内存？"><span class="nav-number">6.</span> <span class="nav-text">Objective-C使用什么机制管理对象内存？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ARC通过什么方式帮助开发者管理内存？"><span class="nav-number">7.</span> <span class="nav-text">ARC通过什么方式帮助开发者管理内存？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ARC下还会存在内存泄露吗？"><span class="nav-number">8.</span> <span class="nav-text">ARC下还会存在内存泄露吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么情况使用weak关键字，相比assign有什么不同？"><span class="nav-number">9.</span> <span class="nav-text">什么情况使用weak关键字，相比assign有什么不同？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#property-的本质是什么？"><span class="nav-number">10.</span> <span class="nav-text">@property 的本质是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#protocol-和-category-中如何使用-property"><span class="nav-number">11.</span> <span class="nav-text">@protocol 和 category 中如何使用 @property</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#property后面可以有哪些修饰符？"><span class="nav-number">12.</span> <span class="nav-text">@property后面可以有哪些修饰符？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用atomic一定是线程安全的吗？"><span class="nav-number">13.</span> <span class="nav-text">使用atomic一定是线程安全的吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synthesize-和-dynamic分别有什么作用"><span class="nav-number">14.</span> <span class="nav-text">@synthesize 和 @dynamic分别有什么作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？"><span class="nav-number">15.</span> <span class="nav-text">ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#怎么用-copy-关键字？"><span class="nav-number">16.</span> <span class="nav-text">怎么用 copy 关键字？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用-property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？"><span class="nav-number">17.</span> <span class="nav-text">用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#void-load-void-initialize-有什么用处？"><span class="nav-number">18.</span> <span class="nav-text">+(void)load; +(void)initialize;有什么用处？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KVO内部实现原理"><span class="nav-number">19.</span> <span class="nav-text">KVO内部实现原理</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>



        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
