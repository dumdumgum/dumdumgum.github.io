<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="Object-c的类可以多重继承么?可以实现多个接口么?Category是什么?重写一个类的方式用继承好还是分类好?为什么?答： Object-c的类不可以多重继承;可以实现多个接口，通过实现多个接口可以完成C++的多重继承;Category是类别，一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系。 import 跟#include 又">
<meta property="og:type" content="article">
<meta property="og:title" content="面试3：基础篇">
<meta property="og:url" content="http://yoursite.com/2017/09/29/面试题（三）-基础篇/index.html">
<meta property="og:site_name" content="dumdum&#39;s Blog&#39;">
<meta property="og:description" content="Object-c的类可以多重继承么?可以实现多个接口么?Category是什么?重写一个类的方式用继承好还是分类好?为什么?答： Object-c的类不可以多重继承;可以实现多个接口，通过实现多个接口可以完成C++的多重继承;Category是类别，一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系。 import 跟#include 又">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-09-29T10:26:26.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面试3：基础篇">
<meta name="twitter:description" content="Object-c的类可以多重继承么?可以实现多个接口么?Category是什么?重写一个类的方式用继承好还是分类好?为什么?答： Object-c的类不可以多重继承;可以实现多个接口，通过实现多个接口可以完成C++的多重继承;Category是类别，一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系。 import 跟#include 又">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/09/29/面试题（三）-基础篇/"/>





  <title>面试3：基础篇 | dumdum's Blog'</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">dumdum's Blog'</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/29/面试题（三）-基础篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dumdum's Blog'">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">面试3：基础篇</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-29T18:19:25+08:00">
                2017-09-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Object-c的类可以多重继承么-可以实现多个接口么-Category是什么-重写一个类的方式用继承好还是分类好-为什么"><a href="#Object-c的类可以多重继承么-可以实现多个接口么-Category是什么-重写一个类的方式用继承好还是分类好-为什么" class="headerlink" title="Object-c的类可以多重继承么?可以实现多个接口么?Category是什么?重写一个类的方式用继承好还是分类好?为什么?"></a>Object-c的类可以多重继承么?可以实现多个接口么?Category是什么?重写一个类的方式用继承好还是分类好?为什么?</h2><p>答： Object-c的类不可以多重继承;可以实现多个接口，通过实现多个接口可以完成C++的多重继承;Category是类别，一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系。</p>
<h2 id="import-跟-include-又什么区别，-class呢-import-lt-gt-跟-import””又什么区别"><a href="#import-跟-include-又什么区别，-class呢-import-lt-gt-跟-import””又什么区别" class="headerlink" title="import 跟#include 又什么区别，@class呢, #import&lt;&gt; 跟 #import””又什么区别?"></a>import 跟#include 又什么区别，@class呢, #import&lt;&gt; 跟 #import””又什么区别?</h2><p>答：#import是Objective-C导入头文件的关键字，#include是C/C++导入头文件的关键字,使用#import头文件会自动只导入一次，不会重复导入，相当于#include和#pragma once;@class告诉编译器某个类的声明，当执行时，才去查看类的实现文件，可以解决头文件的相互包含;#import&lt;&gt;用来包含系统的头文件，#import””用来包含用户头文件。</p>
<h2 id="属性readwrite，readonly，assign，retain，copy，nonatomic-各是什么作用，在那种情况下用"><a href="#属性readwrite，readonly，assign，retain，copy，nonatomic-各是什么作用，在那种情况下用" class="headerlink" title="属性readwrite，readonly，assign，retain，copy，nonatomic 各是什么作用，在那种情况下用?"></a>属性readwrite，readonly，assign，retain，copy，nonatomic 各是什么作用，在那种情况下用?</h2><ol>
<li>readwrite 是可读可写特性;需要生成getter方法和setter方法时</li>
<li>readonly 是只读特性 只会生成getter方法 不会生成setter方法 ;不希望属性在类外改变</li>
<li>assign 是赋值特性，setter方法将传入参数赋值给实例变量;仅设置变量时;</li>
<li>retain 表示持有特性，setter方法将传入参数先保留，再赋值，传入参数的retaincount会+1;</li>
<li>copy 表示赋值特性，setter方法将传入对象复制一份;需要完全一份新的变量时。</li>
<li>nonatomic 非原子操作，决定编译器生成的setter getter是否是原子操作，atomic表示多线程安全，一般使用nonatomic</li>
</ol>
<h2 id="写一个setter方法用于完成-property-nonatomic-retain-NSString-name-写一个setter方法用于完成-property-nonatomic，copy-NSString-name"><a href="#写一个setter方法用于完成-property-nonatomic-retain-NSString-name-写一个setter方法用于完成-property-nonatomic，copy-NSString-name" class="headerlink" title="写一个setter方法用于完成@property (nonatomic,retain)NSString name,写一个setter方法用于完成@property(nonatomic，copy)NSString name"></a>写一个setter方法用于完成@property (nonatomic,retain)NSString <em>name,写一个setter方法用于完成@property(nonatomic，copy)NSString </em>name</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void) setName:(NSString*) str</div><div class="line">&#123;</div><div class="line">[str retain];</div><div class="line">[name release];</div><div class="line">name = str;</div><div class="line">&#125;</div><div class="line">- (void)setName:(NSString *)str</div><div class="line">&#123;</div><div class="line">    id t = [str copy];</div><div class="line">    [name release];</div><div class="line">    name = t;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="对于语句NSString-obj-NSData-alloc-init-obj在编译时和运行时分别时什么类型的对象"><a href="#对于语句NSString-obj-NSData-alloc-init-obj在编译时和运行时分别时什么类型的对象" class="headerlink" title="对于语句NSString *obj = [[NSData alloc] init]; obj在编译时和运行时分别时什么类型的对象?"></a>对于语句NSString *obj = [[NSData alloc] init]; obj在编译时和运行时分别时什么类型的对象?</h2><p>编译时是NSString的类型;运行时是NSData类型的对象</p>
<h2 id="常见的object-c的数据类型有那些，-和C的基本数据类型有什么区别-如：NSInteger和int"><a href="#常见的object-c的数据类型有那些，-和C的基本数据类型有什么区别-如：NSInteger和int" class="headerlink" title="常见的object-c的数据类型有那些， 和C的基本数据类型有什么区别?如：NSInteger和int"></a>常见的object-c的数据类型有那些， 和C的基本数据类型有什么区别?如：NSInteger和int</h2><p>object-c的数据类型有NSString，NSNumber，NSArray，NSMutableArray，NSData等等，这些都是class，创建后便是对象，而C语言的基本数据类型int，只是一定字节的内存空间，用于存放数值;NSInteger是基本数据类型，并不是NSNumber的子类，当然也不是NSObject的子类。NSInteger是基本数据类型Int或者Long的别名(NSInteger的定义typedef long NSInteger)，它的区别在于，NSInteger会根据系统是32位还是64位来决定是本身是int还是Long。</p>
<h2 id="id-声明的对象有什么特性"><a href="#id-声明的对象有什么特性" class="headerlink" title="id 声明的对象有什么特性?"></a>id 声明的对象有什么特性?</h2><p>Id 声明的对象具有运行时的特性，即可以指向任意类型的objcetive-c的对象;</p>
<h2 id="Objective-C如何对内存管理的-说说你的看法和解决方法"><a href="#Objective-C如何对内存管理的-说说你的看法和解决方法" class="headerlink" title="Objective-C如何对内存管理的,说说你的看法和解决方法?"></a>Objective-C如何对内存管理的,说说你的看法和解决方法?</h2><p>Objective-C的内存管理主要有三种方式ARC(自动内存计数)、手动内存计数、内存池。</p>
<ol>
<li>(Garbage Collection)自动内存计数：这种方式和java类似，在你的程序的执行过程中。始终有一个高人在背后准确地帮你收拾垃圾，你不用考虑它什么时候开始工作，怎样工作。你只需要明白，我申请了一段内存空间，当我不用从而这段内存成为垃圾的时候，我就彻底的把它忘记掉，反正那个高人会帮我收拾垃圾。遗憾的是，那个高人需要消耗一定的资源，在携带设备里面，资源是紧俏商品所以iPhone不支持这个功能。所以“Garbage Collection”不是本入门指南的范围，对“Garbage Collection”内部机制感兴趣的同学可以参考一些其他的资料，不过说老实话“Garbage Collection”不大适合适初学者研究。<br>解决: 通过alloc – initial方式创建的, 创建后引用计数+1, 此后每retain一次引用计数+1, 那么在程序中做相应次数的release就好了.</li>
<li>(Reference Counted)手动内存计数：就是说，从一段内存被申请之后，就存在一个变量用于保存这段内存被使用的次数，我们暂时把它称为计数器，当计数器变为0的时候，那么就是释放这段内存的时候。比如说，当在程序A里面一段内存被成功申请完成之后，那么这个计数器就从0变成1(我们把这个过程叫做alloc)，然后程序B也需要使用这个内存，那么计数器就从1变成了2(我们把这个过程叫做retain)。紧接着程序A不再需要这段内存了，那么程序A就把这个计数器减1(我们把这个过程叫做release);程序B也不再需要这段内存的时候，那么也把计数器减1(这个过程还是release)。当系统(也就是Foundation)发现这个计数器变成了0，那么就会调用内存回收程序把这段内存回收(我们把这个过程叫做dealloc)。顺便提一句，如果没有Foundation，那么维护计数器，释放内存等等工作需要你手工来完成。<br>解决:一般是由类的静态方法创建的, 函数名中不会出现alloc或init字样, 如[NSString string]和[NSArray arrayWithObject:], 创建后引用计数+0, 在函数出栈后释放, 即相当于一个栈上的局部变量. 当然也可以通过retain延长对象的生存期.</li>
<li>(NSAutoRealeasePool)内存池：可以通过创建和释放内存池控制内存申请和回收的时机.<br>解决:是由autorelease加入系统内存池, 内存池是可以嵌套的, 每个内存池都需要有一个创建释放对, 就像main函数中写的一样. 使用也很简单, 比如[[[NSString alloc]initialWithFormat:@”Hey you!”] autorelease], 即将一个NSString对象加入到最内层的系统内存池, 当我们释放这个内存池时, 其中的对象都会被释放.</li>
</ol>
<h2 id="原子-atomic-跟非原子-non-atomic-属性有什么区别"><a href="#原子-atomic-跟非原子-non-atomic-属性有什么区别" class="headerlink" title="原子(atomic)跟非原子(non-atomic)属性有什么区别?"></a>原子(atomic)跟非原子(non-atomic)属性有什么区别?</h2><ol>
<li>atomic提供多线程安全。是防止在写未完成的时候被另外一个线程读取，造成数据错误</li>
<li>non-atomic:在自己管理内存的环境中，解析的访问器保留并自动释放返回的值，如果指定了 nonatomic ，那么访问器只是简单地返回这个值。</li>
</ol>
<h2 id="看下面的程序-第一个NSLog会输出什么-这时str的retainCount是多少-第二个和第三个呢-为什么"><a href="#看下面的程序-第一个NSLog会输出什么-这时str的retainCount是多少-第二个和第三个呢-为什么" class="headerlink" title="看下面的程序,第一个NSLog会输出什么?这时str的retainCount是多少?第二个和第三个呢? 为什么?"></a>看下面的程序,第一个NSLog会输出什么?这时str的retainCount是多少?第二个和第三个呢? 为什么?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">NSMutableArray* ary = [[NSMutableArray array] retain];</div><div class="line">NSString *str = [NSString stringWithFormat:@&quot;test&quot;];</div><div class="line">[str retain];</div><div class="line">[ary addObject:str];</div><div class="line">NSLog(@”%@%d”,str,[str retainCount]);</div><div class="line">[str retain];</div><div class="line">[str release];</div><div class="line">[str release];</div><div class="line">NSLog(@”%@%d”,str,[str retainCount]);</div><div class="line">[ary removeAllObjects];</div><div class="line">NSLog(@”%@%d”,str,[str retainCount]);</div></pre></td></tr></table></figure>
<p>str的retainCount创建+1，retain+1，加入数组自动+1 3<br>retain+1，release-1，release-1 2<br>数组删除所有对象，所有数组内的对象自动-1 1</p>
<h2 id="内存管理的几条原则时什么-按照默认法则-那些关键字生成的对象需要手动释放-在和property结合的时候怎样有效的避免内存泄露-谁申请，谁释放"><a href="#内存管理的几条原则时什么-按照默认法则-那些关键字生成的对象需要手动释放-在和property结合的时候怎样有效的避免内存泄露-谁申请，谁释放" class="headerlink" title="内存管理的几条原则时什么?按照默认法则.那些关键字生成的对象需要手动释放?在和property结合的时候怎样有效的避免内存泄露?谁申请，谁释放"></a>内存管理的几条原则时什么?按照默认法则.那些关键字生成的对象需要手动释放?在和property结合的时候怎样有效的避免内存泄露?谁申请，谁释放</h2><p>遵循Cocoa Touch的使用原则;<br>内存管理主要要避免“过早释放”和“内存泄漏”，对于“过早释放”需要注意@property设置特性时，一定要用对特性关键字，对于“内存泄漏”，一定要申请了要负责释放，要细心。<br>关键字alloc 或new 生成的对象需要手动释放;<br>设置正确的property属性，对于retain需要在合适的地方释放，</p>
<h2 id="Object-C中创建线程的方法是什么-如果在主线程中执行代码，方法是什么-如果想延时执行代码、方法又是什么"><a href="#Object-C中创建线程的方法是什么-如果在主线程中执行代码，方法是什么-如果想延时执行代码、方法又是什么" class="headerlink" title="Object C中创建线程的方法是什么?如果在主线程中执行代码，方法是什么?如果想延时执行代码、方法又是什么?"></a>Object C中创建线程的方法是什么?如果在主线程中执行代码，方法是什么?如果想延时执行代码、方法又是什么?</h2><p>线程创建有三种方法：使用NSThread创建、使用GCD的dispatch、使用子类化的NSOperation,然后将其加入NSOperationQueue;在主线程执行代码，方法是performSelectorOnMainThread，如果想延时执行代码可以用performSelector:onThread:withObject:waitUntilDone:</p>
<h2 id="描述一下iOS-SDK中如何实现MVC的开发模式"><a href="#描述一下iOS-SDK中如何实现MVC的开发模式" class="headerlink" title="描述一下iOS SDK中如何实现MVC的开发模式"></a>描述一下iOS SDK中如何实现MVC的开发模式</h2><p>MVC是模型、试图、控制开发模式，对于iOS SDK，所有的View都是视图层的，它应该独立于模型层，由视图控制层来控制。所有的用户数据都是模型层，它应该独立于视图。所有的ViewController都是控制层，由它负责控制视图，访问模型数据。</p>
<h2 id="浅复制和深复制的区别"><a href="#浅复制和深复制的区别" class="headerlink" title="浅复制和深复制的区别?"></a>浅复制和深复制的区别?</h2><p>浅层复制：只复制指向对象的指针，而不复制引用对象本身。<br>深层复制：复制引用对象本身。</p>
<p>意思就是说我有个A对象，复制一份后得到A_copy对象后，对于浅复制来说，A和A_copy指向的是同一个内存资源，复制的只不过是是一个指针，对象本身资源还是只有一份，那如果我们对A_copy执行了修改操作,那么发现A引用的对象同样被修改，这其实违背了我们复制拷贝的一个思想。深复制就好理解了,内存中存在了两份独立对象本身。</p>
<p>用网上一哥们通俗的话将就是：</p>
<p>浅复制好比你和你的影子，你有事了，你的影子也有事了</p>
<p>深复制好比你和你的克隆人，你有事了，你的克隆人没有事。</p>
<h2 id="类别的作用-继承和类别在实现中有何区别"><a href="#类别的作用-继承和类别在实现中有何区别" class="headerlink" title="类别的作用?继承和类别在实现中有何区别?"></a>类别的作用?继承和类别在实现中有何区别?</h2><p>category 可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能删除修改。并且如果类别和原来类中的方法产生名称冲突，则类别将覆盖原来的方法，因为类别具有更高的优先级。</p>
<p>类别主要有3个作用：</p>
<ol>
<li>将类的实现分散到多个不同文件或多个不同框架中。</li>
<li>创建对私有方法的前向引用。</li>
<li>向对象添加非正式协议。</li>
</ol>
<p>继承可以增加，修改或者删除方法，并且可以增加属性。</p>
<h2 id="类别和类扩展的区别。"><a href="#类别和类扩展的区别。" class="headerlink" title="类别和类扩展的区别。"></a>类别和类扩展的区别。</h2><p>category和extensions的不同在于 后者可以添加属性。另外后者添加的方法是必须要实现的。</p>
<p>extensions可以认为是一个私有的Category。</p>
<h2 id="oc中的协议和java中的接口概念有何不同"><a href="#oc中的协议和java中的接口概念有何不同" class="headerlink" title="oc中的协议和java中的接口概念有何不同?"></a>oc中的协议和java中的接口概念有何不同?</h2><p>OC中的代理有2层含义，官方定义为 formal和informal protocol。前者和Java接口一样。</p>
<p>informal protocol中的方法属于设计模式考虑范畴，不是必须实现的，但是如果有实现，就会改变类的属性。</p>
<p>其实关于正式协议，类别和非正式协议我很早前学习的时候大致看过，也写在了学习教程里<br>“非正式协议概念其实就是类别的另一种表达方式“这里有一些你可能希望实现的方法，你可以使用他们更好的完成工作”。<br>这个意思是，这些是可选的。比如我们要一个更好的方法，我们就会申明一个这样的类别去实现。然后你在后期可以直接使用这些更好的方法。<br>这么看，总觉得类别这玩意儿有点像协议的可选协议。<br>现在来看，其实protocal已经开始对两者都统一和规范起来操作，因为资料中说“非正式协议使用interface修饰“，<br>现在我们看到协议中两个修饰词：“必须实现(@requied)”和“可选实现(@optional)”。</p>
<h2 id="什么是KVO和KVC"><a href="#什么是KVO和KVC" class="headerlink" title="什么是KVO和KVC?"></a>什么是KVO和KVC?</h2><p>kvc:键 – 值编码是一种间接访问对象的属性使用字符串来标识属性，而不是通过调用存取方法，直接或通过实例变量访问的机制。<br>很多情况下可以简化程序代码。apple文档其实给了一个很好的例子。<br>kvo:键值观察机制，他提供了观察某一属性变化的方法，极大的简化了代码。<br>具体用看到用到过的一个地方是对于按钮点击变化状态的的监控。<br>比如我自定义的一个button</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[self addObserver:self forKeyPath:@&quot;highlighted&quot; options:0 context:nil];</div><div class="line"></div><div class="line">#pragma mark KVO</div><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context</div><div class="line">&#123;</div><div class="line">    if ([keyPath isEqualToString:@&quot;highlighted&quot;] ) &#123;</div><div class="line">        [self setNeedsDisplay];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于系统是根据keypath去取的到相应的值发生改变，理论上来说是和kvc机制的道理是一样的。<br>对于kvc机制如何通过key寻找到value：<br>“当通过KVC调用对象时，比如：<code>[self valueForKey:@”someKey”]</code>时，程序会自动试图通过几种不同的方式解析这个调用。首先查找对象是否带有 someKey 这个方法，如果没找到，会继续查找对象是否带有someKey这个实例变量(iVar)，如果还没有找到，程序会继续试图调用 <code>-(id) valueForUndefinedKey:</code>这个方法。如果这个方法还是没有被实现的话，程序会抛出一个NSUndefinedKeyException异常错误。<br>(cocoachina.com注：Key-Value Coding查找方法的时候，不仅仅会查找someKey这个方法，还会查找getsomeKey这个方法，前面加一个get，或者_someKey以及_getsomeKey这几种形式。同时，查找实例变量的时候也会不仅仅查找someKey这个变量，也会查找_someKey这个变量是否存在。)<br>设计valueForUndefinedKey:方法的主要目的是当你使用<code>-(id)valueForKey</code>方法从对象中请求值时，对象能够在错误发生前，有最后的机会响应这个请求。这样做有很多好处，下面的两个例子说明了这样做的好处。“<br>来至cocoa，这个说法应该挺有道理。<br>因为我们知道button却是存在一个highlighted实例变量.因此为何上面我们只是add一个相关的keypath就行了，<br>可以按照kvc查找的逻辑理解，就说的过去了。</p>
<h2 id="代理的作用"><a href="#代理的作用" class="headerlink" title="代理的作用?"></a>代理的作用?</h2><p>代理的目的是改变或传递控制链。允许一个类在某些特定时刻通知到其他类，而不需要获取到那些类的指针。可以减少框架复杂度。<br>另外一点，代理可以理解为java中的回调监听机制的一种类似。</p>
<h2 id="我们说的oc是动态运行时语言是什么意思"><a href="#我们说的oc是动态运行时语言是什么意思" class="headerlink" title="我们说的oc是动态运行时语言是什么意思?"></a>我们说的oc是动态运行时语言是什么意思?</h2><p>多态。 主要是将数据类型的确定由编译时，推迟到了运行时。<br>这个问题其实浅涉及到两个概念，运行时和多态。<br>简单来说，运行时机制使我们直到运行时才去决定一个对象的类别，以及调用该类别对象指定方法。<br>多态：不同对象以自己的方式响应相同的消息的能力叫做多态。意思就是假设生物类(life)都用有一个相同的方法-eat;<br>那人类属于生物，猪也属于生物，都继承了life后，实现各自的eat，但是调用是我们只需调用各自的eat方法。(父类指针指向之类对象)<br>也就是不同的对象以自己的方式响应了相同的消息(响应了eat这个选择器)。<br>因此也可以说，运行时机制是多态的基础</p>
<h2 id="通知和协议的不同之处"><a href="#通知和协议的不同之处" class="headerlink" title="通知和协议的不同之处?"></a>通知和协议的不同之处?</h2><p>协议有控制链的关系，通知没有。<br>简单来说，通知的话，它可以一对多，一条消息可以发送给多个消息接受者。<br>代理按我们的理解，到不是直接说不能一对多，比如我们知道的明星经济代理人，很多时候一个经济人负责好几个明星的事务。<br>只是对于不同明星间，代理的事物对象都是不一样的。但是通知就不一样，他只关心发出通知，而不关心多少接收到感兴趣要处理。</p>
<h2 id="关于多态性"><a href="#关于多态性" class="headerlink" title="关于多态性"></a>关于多态性</h2><p>多态，子类指针可以赋值给父类。<br>这个题目其实可以出到一切面向对象语言中，<br>因此关于多态，继承和封装基本最好都有个自我意识的理解，也并非一定要把书上资料上写的能背出来。<br>最重要的是转化成自我理解。</p>
<h2 id="frame和bounds有什么不同"><a href="#frame和bounds有什么不同" class="headerlink" title="frame和bounds有什么不同?"></a>frame和bounds有什么不同?</h2><p>frame指的是：该view在父view坐标系统中的位置和大小。(参照点是父亲的坐标系统)<br>bounds指的是：该view在本身坐标系统中 的位置和大小。(参照点是本身坐标系统)</p>
<h2 id="什么是延迟加载"><a href="#什么是延迟加载" class="headerlink" title="什么是延迟加载?"></a>什么是延迟加载?</h2><p>懒汉模式，只在用到的时候才去初始化。<br>也可以理解成延时加载。<br>我觉得最好也最简单的一个列子就是tableView中图片的加载显示了。<br>一个延时载，避免内存过高，一个异步加载，避免线程堵塞。</p>
<h2 id="类NSObject的那些方法经常被使用"><a href="#类NSObject的那些方法经常被使用" class="headerlink" title="类NSObject的那些方法经常被使用?"></a>类NSObject的那些方法经常被使用?</h2><p>NSObject是Objetive-C的基类，其由NSObject类及一系列协议构成。<br>其中类方法alloc、class、 description 对象方法init、dealloc、– performSelector:withObject:afterDelay:等经常被使用</p>
<h2 id="什么是简便构造方法"><a href="#什么是简便构造方法" class="headerlink" title="什么是简便构造方法?"></a>什么是简便构造方法?</h2><p>简便构造方法一般由CocoaTouch框架提供，如NSNumber的 + numberWithBool: + numberWithChar: + numberWithDouble: + numberWithFloat: + numberWithInt:<br>Foundation下大部分类均有简便构造方法，我们可以通过简便构造方法，获得系统给我们创建好的对象，并且不需要手动释放。</p>
<h2 id="什么是coredata"><a href="#什么是coredata" class="headerlink" title="什么是coredata?"></a>什么是coredata?</h2><p>coredata是苹果提供一套数据保存框架，其基于SQlite</p>
<h2 id="什么是NSManagedObject模型"><a href="#什么是NSManagedObject模型" class="headerlink" title="什么是NSManagedObject模型?"></a>什么是NSManagedObject模型?</h2><p>NSManagedObject是NSObject的子类 ，也是coredata的重要组成部分，它是一个通用的类,实现了core data 模型层所需的基本功能，用户可通过子类化NSManagedObject，建立自己的数据模型。</p>
<h2 id="什么是NSManagedobjectContext"><a href="#什么是NSManagedobjectContext" class="headerlink" title="什么是NSManagedobjectContext?"></a>什么是NSManagedobjectContext?</h2><p>NSManagedobjectContext对象负责应用和数据库之间的交互。</p>
<h2 id="谈谈对Block-的理解-并写出一个使用Block执行UIVew动画"><a href="#谈谈对Block-的理解-并写出一个使用Block执行UIVew动画" class="headerlink" title="谈谈对Block 的理解?并写出一个使用Block执行UIVew动画?"></a>谈谈对Block 的理解?并写出一个使用Block执行UIVew动画?</h2><p>Block是可以获取其他函数局部变量的匿名函数，其不但方便开发，并且可以大幅提高应用的执行效率(多核心CPU可直接处理Block指令)</p>
<pre><code>[UIView transitionWithView:self.view
                duration:0.2
                 options:UIViewAnimationOptionTransitionFlipFromLeft
              animations:^{ 
                  [[blueViewController view] removeFromSuperview]; [[self view] insertSubview:yellowViewController.view atIndex:0]; 
              }
              completion:NULL];
</code></pre><ul>
<li>写出上面代码的Block的定义。</li>
</ul>
<p>typedef void(^animations) (void);<br>typedef void(^completion) (BOOL finished);</p>
<h2 id="多线程是什么"><a href="#多线程是什么" class="headerlink" title="多线程是什么"></a>多线程是什么</h2><p>多线程是个复杂的概念，按字面意思是同步完成多项任务，提高了资源的使用效率，从硬件、操作系统、应用软件不同的角度去看，多线程被赋予不同的内涵，对于硬件，现在市面上多数的CPU都是多核的，多核的CPU运算多线程更为出色;从操作系统角度，是多任务，现在用的主流操作系统都是多任务的，可以一边听歌、一边写博客;对于应用来说，多线程可以让应用有更快的回应，可以在网络下载时，同时响应用户的触摸操作。在iOS应用中，对多线程最初的理解，就是并发，它的含义是原来先做烧水，再摘菜，再炒菜的工作，会变成烧水的同时去摘菜，最后去炒菜。</p>
<h2 id="iOS-中的多线程"><a href="#iOS-中的多线程" class="headerlink" title="iOS 中的多线程"></a>iOS 中的多线程</h2><p>iOS中的多线程，是Cocoa框架下的多线程，通过Cocoa的封装，可以让我们更为方便的使用线程，做过C++的同学可能会对线程有更多的理解，比如线程的创立，信号量、共享变量有认识，Cocoa框架下会方便很多，它对线程做了封装，有些封装，可以让我们创建的对象，本身便拥有线程，也就是线程的对象化抽象，从而减少我们的工程，提供程序的健壮性。<br>GCD是(Grand Central Dispatch)的缩写 ，从系统级别提供的一个易用地多线程类库，具有运行时的特点，能充分利用多核心硬件。GCD的API接口为C语言的函数，函数参数中多数有Block，关于Block的使用参看这里，为我们提供强大的“接口”，对于GCD的使用参见本文<br>NSOperation与Queue</p>
<p>NSOperation是一个抽象类，它封装了线程的细节实现，我们可以通过子类化该对象，加上NSQueue来同面向对象的思维，管理多线程程序。具体可参看这里：一个基于NSOperation的多线程网络访问的项目。</p>
<p>NSThread是一个控制线程执行的对象，它不如NSOperation抽象，通过它我们可以方便的得到一个线程，并控制它。但NSThread的线程之间的并发控制，是需要我们自己来控制的，可以通过NSCondition实现。</p>
<h2 id="在项目什么时候选择使用GCD，什么时候选择NSOperation"><a href="#在项目什么时候选择使用GCD，什么时候选择NSOperation" class="headerlink" title="在项目什么时候选择使用GCD，什么时候选择NSOperation?"></a>在项目什么时候选择使用GCD，什么时候选择NSOperation?</h2><p>项目中使用NSOperation的优点是NSOperation是对线程的高度抽象，在项目中使用它，会使项目的程序结构更好，子类化NSOperation的设计思路，是具有面向对象的优点(复用、封装)，使得实现是多线程支持，而接口简单，建议在复杂项目中使用。<br>项目中使用GCD的优点是GCD本身非常简单、易用，对于不复杂的多线程操作，会节省代码量，而Block参数的使用，会是代码更为易读，建议在简单项目中使用。</p>
<h2 id="block-实现原理"><a href="#block-实现原理" class="headerlink" title="block 实现原理"></a>block 实现原理</h2><p>Objective-C是对C语言的扩展，block的实现是基于指针和函数指针。<br>从计算语言的发展，最早的goto，高级语言的指针，到面向对象语言的block，从机器的思维，一步步接近人的思维，以方便开发人员更为高效、直接的描述出现实的逻辑(需求)。</p>
<p>下面是两篇很好的介绍block实现的博文</p>
<p>iOS中block实现的探究 <a href="http://www.cnblogs.com/HypeCheng/p/4597686.html" target="_blank" rel="external">http://www.cnblogs.com/HypeCheng/p/4597686.html</a></p>
<p>谈Objective-C Block的实现 <a href="http://www.cnblogs.com/HypeCheng/p/4597205.html" target="_blank" rel="external">http://www.cnblogs.com/HypeCheng/p/4597205.html</a></p>
<blockquote>
<p>有什么问题都可联系我们 ：dumdumgum@163.com</p>
</blockquote>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/09/29/面试(二) - 基础篇/" rel="next" title="面试2：基础篇">
                <i class="fa fa-chevron-left"></i> 面试2：基础篇
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/09/30/面试  (四) - 基础篇-4/" rel="prev" title="面试4：基础篇">
                面试4：基础篇 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-c的类可以多重继承么-可以实现多个接口么-Category是什么-重写一个类的方式用继承好还是分类好-为什么"><span class="nav-number">1.</span> <span class="nav-text">Object-c的类可以多重继承么?可以实现多个接口么?Category是什么?重写一个类的方式用继承好还是分类好?为什么?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#import-跟-include-又什么区别，-class呢-import-lt-gt-跟-import””又什么区别"><span class="nav-number">2.</span> <span class="nav-text">import 跟#include 又什么区别，@class呢, #import<> 跟 #import””又什么区别?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#属性readwrite，readonly，assign，retain，copy，nonatomic-各是什么作用，在那种情况下用"><span class="nav-number">3.</span> <span class="nav-text">属性readwrite，readonly，assign，retain，copy，nonatomic 各是什么作用，在那种情况下用?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#写一个setter方法用于完成-property-nonatomic-retain-NSString-name-写一个setter方法用于完成-property-nonatomic，copy-NSString-name"><span class="nav-number">4.</span> <span class="nav-text">写一个setter方法用于完成@property (nonatomic,retain)NSString name,写一个setter方法用于完成@property(nonatomic，copy)NSString name</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对于语句NSString-obj-NSData-alloc-init-obj在编译时和运行时分别时什么类型的对象"><span class="nav-number">5.</span> <span class="nav-text">对于语句NSString *obj = [[NSData alloc] init]; obj在编译时和运行时分别时什么类型的对象?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见的object-c的数据类型有那些，-和C的基本数据类型有什么区别-如：NSInteger和int"><span class="nav-number">6.</span> <span class="nav-text">常见的object-c的数据类型有那些， 和C的基本数据类型有什么区别?如：NSInteger和int</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#id-声明的对象有什么特性"><span class="nav-number">7.</span> <span class="nav-text">id 声明的对象有什么特性?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Objective-C如何对内存管理的-说说你的看法和解决方法"><span class="nav-number">8.</span> <span class="nav-text">Objective-C如何对内存管理的,说说你的看法和解决方法?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原子-atomic-跟非原子-non-atomic-属性有什么区别"><span class="nav-number">9.</span> <span class="nav-text">原子(atomic)跟非原子(non-atomic)属性有什么区别?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#看下面的程序-第一个NSLog会输出什么-这时str的retainCount是多少-第二个和第三个呢-为什么"><span class="nav-number">10.</span> <span class="nav-text">看下面的程序,第一个NSLog会输出什么?这时str的retainCount是多少?第二个和第三个呢? 为什么?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存管理的几条原则时什么-按照默认法则-那些关键字生成的对象需要手动释放-在和property结合的时候怎样有效的避免内存泄露-谁申请，谁释放"><span class="nav-number">11.</span> <span class="nav-text">内存管理的几条原则时什么?按照默认法则.那些关键字生成的对象需要手动释放?在和property结合的时候怎样有效的避免内存泄露?谁申请，谁释放</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-C中创建线程的方法是什么-如果在主线程中执行代码，方法是什么-如果想延时执行代码、方法又是什么"><span class="nav-number">12.</span> <span class="nav-text">Object C中创建线程的方法是什么?如果在主线程中执行代码，方法是什么?如果想延时执行代码、方法又是什么?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#描述一下iOS-SDK中如何实现MVC的开发模式"><span class="nav-number">13.</span> <span class="nav-text">描述一下iOS SDK中如何实现MVC的开发模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#浅复制和深复制的区别"><span class="nav-number">14.</span> <span class="nav-text">浅复制和深复制的区别?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类别的作用-继承和类别在实现中有何区别"><span class="nav-number">15.</span> <span class="nav-text">类别的作用?继承和类别在实现中有何区别?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类别和类扩展的区别。"><span class="nav-number">16.</span> <span class="nav-text">类别和类扩展的区别。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#oc中的协议和java中的接口概念有何不同"><span class="nav-number">17.</span> <span class="nav-text">oc中的协议和java中的接口概念有何不同?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是KVO和KVC"><span class="nav-number">18.</span> <span class="nav-text">什么是KVO和KVC?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代理的作用"><span class="nav-number">19.</span> <span class="nav-text">代理的作用?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#我们说的oc是动态运行时语言是什么意思"><span class="nav-number">20.</span> <span class="nav-text">我们说的oc是动态运行时语言是什么意思?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通知和协议的不同之处"><span class="nav-number">21.</span> <span class="nav-text">通知和协议的不同之处?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于多态性"><span class="nav-number">22.</span> <span class="nav-text">关于多态性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#frame和bounds有什么不同"><span class="nav-number">23.</span> <span class="nav-text">frame和bounds有什么不同?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是延迟加载"><span class="nav-number">24.</span> <span class="nav-text">什么是延迟加载?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类NSObject的那些方法经常被使用"><span class="nav-number">25.</span> <span class="nav-text">类NSObject的那些方法经常被使用?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是简便构造方法"><span class="nav-number">26.</span> <span class="nav-text">什么是简便构造方法?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是coredata"><span class="nav-number">27.</span> <span class="nav-text">什么是coredata?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是NSManagedObject模型"><span class="nav-number">28.</span> <span class="nav-text">什么是NSManagedObject模型?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是NSManagedobjectContext"><span class="nav-number">29.</span> <span class="nav-text">什么是NSManagedobjectContext?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#谈谈对Block-的理解-并写出一个使用Block执行UIVew动画"><span class="nav-number">30.</span> <span class="nav-text">谈谈对Block 的理解?并写出一个使用Block执行UIVew动画?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程是什么"><span class="nav-number">31.</span> <span class="nav-text">多线程是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iOS-中的多线程"><span class="nav-number">32.</span> <span class="nav-text">iOS 中的多线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在项目什么时候选择使用GCD，什么时候选择NSOperation"><span class="nav-number">33.</span> <span class="nav-text">在项目什么时候选择使用GCD，什么时候选择NSOperation?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#block-实现原理"><span class="nav-number">34.</span> <span class="nav-text">block 实现原理</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>



        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
