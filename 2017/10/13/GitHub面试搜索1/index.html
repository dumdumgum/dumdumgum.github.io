<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="什么情况使用 weak 关键字，相比 assign 有什么不同？什么情况使用 weak 关键字？  在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性 自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。在下文也有论述：">
<meta property="og:type" content="article">
<meta property="og:title" content="GitHub面试搜索1">
<meta property="og:url" content="http://yoursite.com/2017/10/13/GitHub面试搜索1/index.html">
<meta property="og:site_name" content="dumdum&#39;s Blog&#39;">
<meta property="og:description" content="什么情况使用 weak 关键字，相比 assign 有什么不同？什么情况使用 weak 关键字？  在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性 自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。在下文也有论述：">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://camo.githubusercontent.com/8a5fa34435801cc4c2715d8880f3abd45be6a6c5/687474703a2f2f692e696d6775722e636f6d2f566c564b6c384c2e706e67">
<meta property="og:image" content="https://camo.githubusercontent.com/bf346edc21ab4b3387906602249b357d250ab1c2/687474703a2f2f692e696d6775722e636f6d2f6541483559576e2e706e67">
<meta property="og:updated_time" content="2018-01-16T07:05:21.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="GitHub面试搜索1">
<meta name="twitter:description" content="什么情况使用 weak 关键字，相比 assign 有什么不同？什么情况使用 weak 关键字？  在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性 自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。在下文也有论述：">
<meta name="twitter:image" content="https://camo.githubusercontent.com/8a5fa34435801cc4c2715d8880f3abd45be6a6c5/687474703a2f2f692e696d6775722e636f6d2f566c564b6c384c2e706e67">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/10/13/GitHub面试搜索1/"/>





  <title>GitHub面试搜索1 | dumdum's Blog'</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">dumdum's Blog'</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/13/GitHub面试搜索1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dumdum's Blog'">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">GitHub面试搜索1</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-13T17:57:27+08:00">
                2017-10-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="什么情况使用-weak-关键字，相比-assign-有什么不同？"><a href="#什么情况使用-weak-关键字，相比-assign-有什么不同？" class="headerlink" title="什么情况使用 weak 关键字，相比 assign 有什么不同？"></a>什么情况使用 weak 关键字，相比 assign 有什么不同？</h2><p>什么情况使用 weak 关键字？</p>
<ol>
<li>在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性</li>
<li>自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。在下文也有论述：<strong><em>《IBOutlet连出来的视图属性为什么可以被设置成weak?》</em></strong></li>
</ol>
<p>不同点：</p>
<p>weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。 而 assign 的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或 NSlnteger 等)的简单赋值操作。</p>
<p>assign 可以用非 OC 对象,而 weak 必须用于 OC 对象</p>
<h2 id="怎么用-copy-关键字？"><a href="#怎么用-copy-关键字？" class="headerlink" title="怎么用 copy 关键字？"></a>怎么用 copy 关键字？</h2><p>用途：</p>
<ol>
<li>NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；</li>
<li>block 也经常使用 copy 关键字，具体原因见<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html#//apple_ref/doc/uid/TP40011210-CH8-SW12" target="_blank" rel="external">官方文档：Objects Use Properties to Keep Track of Blocks：</a></li>
</ol>
<p>block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.在 ARC 中写不写都行：对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。你也许会感觉我这种做法有些怪异，不需要写依然写。如果你这样想，其实是你“日用而不知”，你平时开发中是经常在用我说的这种做法的，比如下面的属性不写copy也行，但是你会选择写还是不写呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, copy) NSString *userId;</div><div class="line"></div><div class="line">- (instancetype)initWithUserId:(NSString *)userId &#123;</div><div class="line">   self = [super init];</div><div class="line">   if (!self) &#123;</div><div class="line">       return nil;</div><div class="line">   &#125;</div><div class="line">   _userId = [userId copy];</div><div class="line">   return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://camo.githubusercontent.com/8a5fa34435801cc4c2715d8880f3abd45be6a6c5/687474703a2f2f692e696d6775722e636f6d2f566c564b6c384c2e706e67" alt=""></p>
<p>下面做下解释： copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。 当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。</p>
<blockquote>
<p>用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p>
</blockquote>
<h2 id="这个写法会出什么问题：-property-copy-NSMutableArray-array"><a href="#这个写法会出什么问题：-property-copy-NSMutableArray-array" class="headerlink" title="这个写法会出什么问题： @property (copy) NSMutableArray *array;"></a>这个写法会出什么问题： @property (copy) NSMutableArray *array;</h2><p>两个问题：1、添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃.因为 copy 就是复制一个不可变 NSArray 的对象；2、使用了 atomic 属性会严重影响性能 ；</p>
<p>第1条的原因在下文中有论述<strong><em>《用@property声明的NSString（或NSArray，NSDictionary）经常使用 copy 关键字，为什么？如果改用strong关键字，可能造成什么问题？》</em></strong> 以及上文<strong><em>《怎么用 copy 关键字？》</em></strong>也有论述。</p>
<p>比如下面的代码就会发生崩溃</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// .h文件</div><div class="line">// http://weibo.com/luohanchenyilong/</div><div class="line">// https://github.com/ChenYilong</div><div class="line">// 下面的代码就会发生崩溃</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSMutableArray *mutableArray;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// .m文件</div><div class="line">// http://weibo.com/luohanchenyilong/</div><div class="line">// https://github.com/ChenYilong</div><div class="line">// 下面的代码就会发生崩溃</div><div class="line"></div><div class="line">NSMutableArray *array = [NSMutableArray arrayWithObjects:@1,@2,nil];</div><div class="line">self.mutableArray = array;</div><div class="line">[self.mutableArray removeObjectAtIndex:0];</div></pre></td></tr></table></figure>
<p>接下来就会奔溃：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-[__NSArrayI removeObjectAtIndex:]: unrecognized selector sent to instance 0x7fcd1bc30460</div></pre></td></tr></table></figure>
<p>第2条原因如下：</p>
<blockquote>
<p>该属性使用了同步锁，会在创建时生成一些额外的代码用于帮助编写多线程程序，这会带来性能问题，通过声明 nonatomic 可以节省这些虽然很小但是不必要额外开销。</p>
</blockquote>
<p>在默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用同步锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的”(atomic))。</p>
<p>在iOS开发中，你会发现，几乎所有属性都声明为 nonatomic。</p>
<p>一般情况下并不要求属性必须是“原子的”，因为这并不能保证“线程安全” ( thread safety)，若要实现“线程安全”的操作，还需采用更为深层的锁定机制才行。例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为 atomic，也还是会读到不同的属性值。</p>
<p>因此，开发iOS程序时一般都会使用 nonatomic 属性。但是在开发 Mac OS X 程序时，使用 atomic 属性通常都不会有性能瓶颈。</p>
<h2 id="如何让自己的类用-copy-修饰符？如何重写带-copy-关键字的-setter？"><a href="#如何让自己的类用-copy-修饰符？如何重写带-copy-关键字的-setter？" class="headerlink" title="如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？"></a>如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</h2><blockquote>
<p>若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。</p>
</blockquote>
<p>具体步骤：</p>
<ol>
<li>需声明该类遵从 NSCopying 协议</li>
<li>实现 NSCopying 协议。该协议只有一个方法:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)copyWithZone:(NSZone *)zone;</div></pre></td></tr></table></figure>
<p>注意：一提到让自己的类用 copy 修饰符，我们总是想覆写copy方法，其实真正需要实现的却是 “copyWithZone” 方法。</p>
<p>以第一题的代码为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// .h文件</div><div class="line">// http://weibo.com/luohanchenyilong/</div><div class="line">// https://github.com/ChenYilong</div><div class="line">// 修改完的代码</div><div class="line"></div><div class="line">typedef NS_ENUM(NSInteger, CYLSex) &#123;</div><div class="line">     CYLSexMan,</div><div class="line">     CYLSexWoman</div><div class="line">&#125;;</div><div class="line"></div><div class="line">@interface CYLUser : NSObject&lt;NSCopying&gt;</div><div class="line"></div><div class="line">@property (nonatomic, readonly, copy) NSString *name;</div><div class="line">@property (nonatomic, readonly, assign) NSUInteger age;</div><div class="line">@property (nonatomic, readonly, assign) CYLSex sex;</div><div class="line"></div><div class="line">- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;</div><div class="line">+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>然后实现协议中规定的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (id)copyWithZone:(NSZone *)zone &#123;</div><div class="line">	CYLUser *copy = [[[self class] allocWithZone:zone] initWithName:_name age:_age sex:_sex];</div><div class="line">	return copy;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但在实际的项目中，不可能这么简单，遇到更复杂一点，比如类对象中的数据结构可能并未在初始化方法中设置好，需要另行设置。举个例子，假如 CYLUser 中含有一个数组，与其他 CYLUser 对象建立或解除朋友关系的那些方法都需要操作这个数组。那么在这种情况下，你得把这个包含朋友对象的数组也一并拷贝过来。下面列出了实现此功能所需的全部代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// .h文件</div><div class="line">// http://weibo.com/luohanchenyilong/</div><div class="line">// https://github.com/ChenYilong</div><div class="line">// 以第一题《风格纠错题》里的代码为例</div><div class="line"></div><div class="line">typedef NS_ENUM(NSInteger, CYLSex) &#123;</div><div class="line">    CYLSexMan,</div><div class="line">    CYLSexWoman</div><div class="line">&#125;;</div><div class="line"></div><div class="line">@interface CYLUser : NSObject&lt;NSCopying&gt;</div><div class="line"></div><div class="line">@property (nonatomic, readonly, copy) NSString *name;</div><div class="line">@property (nonatomic, readonly, assign) NSUInteger age;</div><div class="line">@property (nonatomic, readonly, assign) CYLSex sex;</div><div class="line"></div><div class="line">- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;</div><div class="line">+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;</div><div class="line">- (void)addFriend:(CYLUser *)user;</div><div class="line">- (void)removeFriend:(CYLUser *)user;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">// .m文件</div><div class="line">// http://weibo.com/luohanchenyilong/</div><div class="line">// https://github.com/ChenYilong</div><div class="line">//</div><div class="line"></div><div class="line">@implementation CYLUser &#123;</div><div class="line">   NSMutableSet *_friends;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setName:(NSString *)name &#123;</div><div class="line">   _name = [name copy];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)initWithName:(NSString *)name</div><div class="line">                        age:(NSUInteger)age</div><div class="line">                        sex:(CYLSex)sex &#123;</div><div class="line">   if(self = [super init]) &#123;</div><div class="line">       _name = [name copy];</div><div class="line">       _age = age;</div><div class="line">       _sex = sex;</div><div class="line">       _friends = [[NSMutableSet alloc] init];</div><div class="line">   &#125;</div><div class="line">   return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)addFriend:(CYLUser *)user &#123;</div><div class="line">   [_friends addObject:user];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)removeFriend:(CYLUser *)user &#123;</div><div class="line">   [_friends removeObject:user];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)copyWithZone:(NSZone *)zone &#123;</div><div class="line">   CYLUser *copy = [[[self class] allocWithZone:zone]</div><div class="line">                    initWithName:_name</div><div class="line">                    age:_age</div><div class="line">                    sex:_sex];</div><div class="line">   copy-&gt;_friends = [_friends mutableCopy];</div><div class="line">   return copy;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)deepCopy &#123;</div><div class="line">   CYLUser *copy = [[[self class] alloc]</div><div class="line">                    initWithName:_name</div><div class="line">                    age:_age</div><div class="line">                    sex:_sex];</div><div class="line">   copy-&gt;_friends = [[NSMutableSet alloc] initWithSet:_friends</div><div class="line">                                            copyItems:YES];</div><div class="line">   return copy;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>以上做法能满足基本的需求，但是也有缺陷：</p>
<blockquote>
<p>如果你所写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。</p>
</blockquote>
<p>【注：深浅拷贝的概念，在下文中有介绍，详见下文的：<strong><em>用@property声明的 NSString（或NSArray，NSDictionary）经常使用 copy 关键字，为什么？如果改用 strong 关键字，可能造成什么问题？</em></strong>】</p>
<p>在例子中，存放朋友对象的 set 是用 “copyWithZone:” 方法来拷贝的，这种浅拷贝方式不会逐个复制 set 中的元素。若需要深拷贝的话，则可像下面这样，编写一个专供深拷贝所用的方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (id)deepCopy &#123;</div><div class="line">   CYLUser *copy = [[[self class] alloc]</div><div class="line">                    initWithName:_name</div><div class="line">                    age:_age</div><div class="line">                    sex:_sex];</div><div class="line">   copy-&gt;_friends = [[NSMutableSet alloc] initWithSet:_friends</div><div class="line">                                            copyItems:YES];</div><div class="line">   return copy;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至于<strong><em>如何重写带 copy 关键字的 setter</em></strong>这个问题，</p>
<p>如果抛开本例来回答的话，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)setName:(NSString *)name &#123;</div><div class="line">    //[_name release];</div><div class="line">    _name = [name copy];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过也有争议，有人说“苹果如果像下面这样干，是不是效率会高一些？”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)setName:(NSString *)name &#123;</div><div class="line">   if (_name != name) &#123;</div><div class="line">       //[_name release];//MRC</div><div class="line">       _name = [name copy];</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的"><a href="#property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的" class="headerlink" title="@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的"></a>@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</h2><p>@property 的本质是什么？</p>
<blockquote>
<p>@property = ivar + getter + setter;</p>
</blockquote>
<p>下面解释下：</p>
<blockquote>
<p>“属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。</p>
</blockquote>
<p>“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为 Objective-C 2.0 的一部分。 而在正规的 Objective-C 编码风格中，存取方法有着严格的命名规范。 正因为有了这种严格的命名规范，所以 Objective-C 这门语言才能根据名称自动创建出存取方法。其实也可以把属性当做一种关键字，其表示:</p>
<blockquote>
<p>编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。 所以你也可以这么说：<br>@property = getter + setter;</p>
</blockquote>
<p>例如下面这个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@interface Person : NSObject</div><div class="line">@property NSString *firstName;</div><div class="line">@property NSString *lastName;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>上述代码写出来的类与下面这种写法等效：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@interface Person : NSObject</div><div class="line">- (NSString *)firstName;</div><div class="line">- (void)setFirstName:(NSString *)firstName;</div><div class="line">- (NSString *)lastName;</div><div class="line">- (void)setLastName:(NSString *)lastName;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>更新：</p>
<p>property在runtime中是<code>objc_property_t</code>定义如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_property *objc_property_t;</div></pre></td></tr></table></figure>
<p>而<code>objc_property</code>是一个结构体，包括name和attributes，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct property_t &#123;</div><div class="line">    const char *name;</div><div class="line">    const char *attributes;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>而attributes本质是<code>objc_property_attribute_t</code>，定义了property的一些属性，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/// Defines a property attribute</div><div class="line">typedef struct &#123;</div><div class="line">    const char *name;           /**&lt; The name of the attribute */</div><div class="line">    const char *value;          /**&lt; The value of the attribute (usually empty) */</div><div class="line">&#125; objc_property_attribute_t;</div></pre></td></tr></table></figure>
<p>而attributes的具体内容是什么呢？其实，包括：类型，原子性，内存语义和对应的实例变量。</p>
<p>例如：我们定义一个string的property<code>@property (nonatomic, copy) NSString *string;</code>，通过 <code>property_getAttributes(property)</code>获取到attributes并打印出来之后的结果为<code>T@&quot;NSString&quot;,C,N,V_string</code></p>
<p>其中T就代表类型，可参阅<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="external">Type Encodings</a>，C就代表Copy，N代表nonatomic，V就代表对于的实例变量。</p>
<p>ivar、getter、setter 是如何生成并添加到这个类中的?</p>
<blockquote>
<p>“自动合成”( autosynthesis)</p>
</blockquote>
<p>完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译 器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为 <code>_firstName</code> 与 <code>_lastName</code>。也可以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@implementation Person</div><div class="line">@synthesize firstName = _myFirstName;</div><div class="line">@synthesize lastName = _myLastName;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>反编译过相关的代码,他大致生成了五个东西</p>
<ol>
<li>OBJC<em>IVAR</em>$类名$属性名称 ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，表示该变量距离存放对象的内存区域的起始地址有多远。</li>
<li>setter 与 getter 方法对应的实现函数</li>
<li>ivar_list ：成员变量列表</li>
<li>method_list ：方法列表</li>
<li>prop_list ：属性列表</li>
</ol>
<p>也就是说我们每次在增加一个属性,系统都会在 ivar_list 中添加一个成员变量的描述,在 method_list 中增加 setter 与 getter 方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出 setter 与 getter 方法对应的实现,在 setter 方法中从偏移量的位置开始赋值,在 getter 方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转.</p>
<h2 id="protocol-和-category-中如何使用-property"><a href="#protocol-和-category-中如何使用-property" class="headerlink" title="@protocol 和 category 中如何使用 @property"></a>@protocol 和 category 中如何使用 @property</h2><p>在 protocol 中使用 property 只会生成 setter 和 getter 方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性</p>
<p>category 使用 @property 也是只会生成 setter 和 getter 方法的声明,如果我们真的需要给 category 增加属性的实现,需要借助于运行时的两个函数：</p>
<ol>
<li><p>objc_setAssociatedObject</p>
</li>
<li><p>objc_getAssociatedObject</p>
</li>
</ol>
<h2 id="runtime-如何实现-weak-属性"><a href="#runtime-如何实现-weak-属性" class="headerlink" title="runtime 如何实现 weak 属性"></a>runtime 如何实现 weak 属性</h2><p>要实现 weak 属性，首先要搞清楚 weak 属性的特点：</p>
<blockquote>
<p>weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同 assign 类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。</p>
</blockquote>
<p>那么 runtime 如何实现 weak 变量的自动置nil？</p>
<blockquote>
<p>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。</p>
</blockquote>
<p>（注：在下文的 <strong><em>《使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？》</em></strong> 里给出的“对象的内存销毁时间表”也提到__weak引用的解除时间。）</p>
<p>先看下 runtime 里源码的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* The internal structure stored in the weak references table. </div><div class="line">* It maintains and stores</div><div class="line">* a hash set of weak references pointing to an object.</div><div class="line">* If out_of_line==0, the set is instead a small inline array.</div><div class="line">*/</div><div class="line">#define WEAK_INLINE_COUNT 4</div><div class="line">struct weak_entry_t &#123;</div><div class="line">   DisguisedPtr&lt;objc_object&gt; referent;</div><div class="line">   union &#123;</div><div class="line">       struct &#123;</div><div class="line">           weak_referrer_t *referrers;</div><div class="line">           uintptr_t        out_of_line : 1;</div><div class="line">           uintptr_t        num_refs : PTR_MINUS_1;</div><div class="line">           uintptr_t        mask;</div><div class="line">           uintptr_t        max_hash_displacement;</div><div class="line">       &#125;;</div><div class="line">       struct &#123;</div><div class="line">           // out_of_line=0 is LSB of one of these (don&apos;t care which)</div><div class="line">           weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];</div><div class="line">       &#125;;</div><div class="line">   &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/**</div><div class="line">* The global weak references table. Stores object ids as keys,</div><div class="line">* and weak_entry_t structs as their values.</div><div class="line">*/</div><div class="line">struct weak_table_t &#123;</div><div class="line">   weak_entry_t *weak_entries;</div><div class="line">   size_t    num_entries;</div><div class="line">   uintptr_t mask;</div><div class="line">   uintptr_t max_hash_displacement;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>具体完整实现参照 <a href="https://opensource.apple.com/source/objc4/objc4-646/runtime/objc-weak.h" target="_blank" rel="external">objc/objc-weak.h</a> 。</p>
<p>我们可以设计一个函数（伪代码）来表示上述机制：</p>
<p><code>objc_storeWeak(&amp;a, b)</code>函数：</p>
<p><code>objc_storeWeak</code>函数把第二个参数–赋值对象（b）的内存地址作为键值key，将第一个参数–weak修饰的属性变量（a）的内存地址（&amp;a）作为value，注册到 weak 表中。如果第二个参数（b）为0（nil），那么把变量（a）的内存地址（&amp;a）从weak表中删除，</p>
<p>你可以把<code>objc_storeWeak(&amp;a, b)</code>理解为：<code>objc_storeWeak(value, key)</code>，并且当key变nil，将value置nil。</p>
<p>在b非nil时，a和b指向同一个内存地址，在b变nil时，a变nil。此时向a发送消息不会崩溃：在Objective-C中向nil发送消息是安全的。</p>
<p>而如果a是由 assign 修饰的，则： 在 b 非 nil 时，a 和 b 指向同一个内存地址，在 b 变 nil 时，a 还是指向该内存地址，变野指针。此时向 a 发送消息极易崩溃。</p>
<p>下面我们将基于<code>objc_storeWeak(&amp;a, b)</code>函数，使用伪代码模拟“runtime如何实现weak属性”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 使用伪代码模拟：runtime如何实现weak属性</div><div class="line">// http://weibo.com/luohanchenyilong/</div><div class="line">// https://github.com/ChenYilong</div><div class="line"></div><div class="line"> id obj1;</div><div class="line"> objc_initWeak(&amp;obj1, obj);</div><div class="line">/*obj引用计数变为0，变量作用域结束*/</div><div class="line"> objc_destroyWeak(&amp;obj1);</div></pre></td></tr></table></figure>
<p>下面对用到的两个方法<code>objc_initWeak</code>和<code>objc_destroyWeak</code>做下解释：</p>
<p>总体说来，作用是： 通过objc_initWeak函数初始化“附有weak修饰符的变量（obj1）”，在变量作用域结束时通过<code>objc_destoryWeak</code>函数释放该变量（obj1）。</p>
<p>下面分别介绍下方法的内部实现：</p>
<p><code>objc_initWeak</code>函数的实现是这样的：在将“附有weak修饰符的变量（obj1）”初始化为0（nil）后，会将“赋值对象”（obj）作为参数，调用<code>objc_storeWeak</code>函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obj1 = 0；</div><div class="line">obj_storeWeak(&amp;obj1, obj);</div></pre></td></tr></table></figure>
<p>也就是说：</p>
<blockquote>
<p>weak 修饰的指针默认值是 nil （在Objective-C中向nil发送消息是安全的）</p>
</blockquote>
<p>然后<code>obj_destroyWeak</code>函数将0（nil）作为参数，调用<code>objc_storeWeak</code>函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_storeWeak(&amp;obj1, 0);</div></pre></td></tr></table></figure>
<p>前面的源代码与下列源代码相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 使用伪代码模拟：runtime如何实现weak属性</div><div class="line">// http://weibo.com/luohanchenyilong/</div><div class="line">// https://github.com/ChenYilong</div><div class="line"></div><div class="line">id obj1;</div><div class="line">obj1 = 0;</div><div class="line">objc_storeWeak(&amp;obj1, obj);</div><div class="line">/* ... obj的引用计数变为0，被置nil ... */</div><div class="line">objc_storeWeak(&amp;obj1, 0);</div></pre></td></tr></table></figure>
<p><code>objc_storeWeak</code> 函数把第二个参数–赋值对象（obj）的内存地址作为键值，将第一个参数–weak修饰的属性变量（obj1）的内存地址注册到 weak 表中。如果第二个参数（obj）为0（nil），那么把变量（obj1）的地址从 weak 表中删除，在后面的相关一题会详解。</p>
<p>使用伪代码是为了方便理解，下面我们“真枪实弹”地实现下：</p>
<blockquote>
<p>如何让不使用weak修饰的@property，拥有weak的效果。</p>
</blockquote>
<p>我们从setter方法入手：</p>
<p>（注意以下的 cyl_runAtDealloc 方法实现仅仅用于模拟原理，如果想用于项目中，还需要考虑更复杂的场景，想在实际项目使用的话，可以使用我写的一个小库，可以使用 CocoaPods 在项目中使用： <a href="https://github.com/ChenYilong/CYLDeallocBlockExecutor" target="_blank" rel="external">CYLDeallocBlockExecutor</a> ）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)setObject:(NSObject *)object</div><div class="line">&#123;</div><div class="line">   objc_setAssociatedObject(self, &quot;object&quot;, object, OBJC_ASSOCIATION_ASSIGN);</div><div class="line">   [object cyl_runAtDealloc:^&#123;</div><div class="line">       _object = nil;</div><div class="line">   &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是有两个步骤：</p>
<ol>
<li>在setter方法中做如下设置：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_setAssociatedObject(self, &quot;object&quot;, object, OBJC_ASSOCIATION_ASSIGN);</div></pre></td></tr></table></figure>
<ol>
<li>在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。做到这点，同样要借助 runtime：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//要销毁的目标对象</div><div class="line">id objectToBeDeallocated;</div><div class="line">//可以理解为一个“事件”：当上面的目标对象销毁时，同时要发生的“事件”。</div><div class="line">id objectWeWantToBeReleasedWhenThatHappens;</div><div class="line">objc_setAssociatedObject(objectToBeDeallocted,</div><div class="line">                        someUniqueKey,</div><div class="line">                        objectWeWantToBeReleasedWhenThatHappens,</div><div class="line">                        OBJC_ASSOCIATION_RETAIN);</div></pre></td></tr></table></figure>
<p>知道了思路，我们就开始实现 <code>cyl_runAtDealloc</code> 方法，实现过程分两部分：</p>
<p>第一部分：创建一个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助 block 执行“事件”。</p>
<p>// .h文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// .h文件</div><div class="line">// http://weibo.com/luohanchenyilong/</div><div class="line">// https://github.com/ChenYilong</div><div class="line">// 这个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助block执行“事件”。</div><div class="line"></div><div class="line">typedef void (^voidBlock)(void);</div><div class="line"></div><div class="line">@interface CYLBlockExecutor : NSObject</div><div class="line"></div><div class="line">- (id)initWithBlock:(voidBlock)block;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>// .m文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// .m文件</div><div class="line">// http://weibo.com/luohanchenyilong/</div><div class="line">// https://github.com/ChenYilong</div><div class="line">// 这个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助block执行“事件”。</div><div class="line"></div><div class="line">#import &quot;CYLBlockExecutor.h&quot;</div><div class="line"></div><div class="line">@interface CYLBlockExecutor() &#123;</div><div class="line">   voidBlock _block;</div><div class="line">&#125;</div><div class="line">@implementation CYLBlockExecutor</div><div class="line"></div><div class="line">- (id)initWithBlock:(voidBlock)aBlock</div><div class="line">&#123;</div><div class="line">   self = [super init];</div><div class="line">   </div><div class="line">   if (self) &#123;</div><div class="line">       _block = [aBlock copy];</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)dealloc</div><div class="line">&#123;</div><div class="line">   _block ? _block() : nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>第二部分：核心代码：利用runtime实现cyl_runAtDealloc方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">// CYLNSObject+RunAtDealloc.h文件</div><div class="line">// http://weibo.com/luohanchenyilong/</div><div class="line">// https://github.com/ChenYilong</div><div class="line">// 利用runtime实现cyl_runAtDealloc方法</div><div class="line"></div><div class="line">#import &quot;CYLBlockExecutor.h&quot;</div><div class="line"></div><div class="line">const void *runAtDeallocBlockKey = &amp;runAtDeallocBlockKey;</div><div class="line"></div><div class="line">@interface NSObject (CYLRunAtDealloc)</div><div class="line"></div><div class="line">- (void)cyl_runAtDealloc:(voidBlock)block;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">// CYLNSObject+RunAtDealloc.m文件</div><div class="line">// http://weibo.com/luohanchenyilong/</div><div class="line">// https://github.com/ChenYilong</div><div class="line">// 利用runtime实现cyl_runAtDealloc方法</div><div class="line"></div><div class="line">#import &quot;CYLNSObject+RunAtDealloc.h&quot;</div><div class="line">#import &quot;CYLBlockExecutor.h&quot;</div><div class="line"></div><div class="line">@implementation NSObject (CYLRunAtDealloc)</div><div class="line"></div><div class="line">- (void)cyl_runAtDealloc:(voidBlock)block</div><div class="line">&#123;</div><div class="line">   if (block) &#123;</div><div class="line">       CYLBlockExecutor *executor = [[CYLBlockExecutor alloc] initWithBlock:block];</div><div class="line">       </div><div class="line">       objc_setAssociatedObject(self,</div><div class="line">                                runAtDeallocBlockKey,</div><div class="line">                                executor,</div><div class="line">                                OBJC_ASSOCIATION_RETAIN);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>使用方法： 导入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#import &quot;CYLNSObject+RunAtDealloc.h&quot;</div></pre></td></tr></table></figure>
<p>然后就可以使用了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSObject *foo = [[NSObject alloc] init];</div><div class="line"></div><div class="line">[foo cyl_runAtDealloc:^&#123;</div><div class="line">   NSLog(@&quot;正在释放foo!&quot;);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>如果对 cyl_runAtDealloc 的实现原理有兴趣，可以看下我写的一个小库，可以使用 CocoaPods 在项目中使用：<a href="https://github.com/ChenYilong/CYLDeallocBlockExecutor" target="_blank" rel="external">CYLDeallocBlockExecutor</a></p>
<p>参考博文： Fun With the Objective-C Runtime: Run Code at Deallocation of Any Object</p>
<h2 id="property中有哪些属性关键字？-property-后面可以有哪些修饰符？"><a href="#property中有哪些属性关键字？-property-后面可以有哪些修饰符？" class="headerlink" title="@property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？"></a>@property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？</h2><p>属性可以拥有的特质分为四类:</p>
<ol>
<li>原子性—nonatomic 特质</li>
</ol>
<p>在默认情况下，由编译器合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用自旋锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的” ( atomic) )，但是仍然可以在属性特质中写明这一点，编译器不会报错。若是自己定义存取方法，那么就应该遵从与属性特质相符的原子性。</p>
<ol>
<li><p>读/写权限—readwrite(读写)、readonly (只读)</p>
</li>
<li><p>内存管理语义—assign、strong、 weak、unsafe_unretained、copy</p>
</li>
<li><p>方法名—getter=<name> 、setter=<name></name></name></p>
</li>
</ol>
<p>getter=<name>的样式：</name></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, getter=isOn) BOOL on;</div></pre></td></tr></table></figure>
<p>（ <code>setter=</code>这种不常用，也不推荐使用。故不在这里给出写法。）</p>
<p>setter=<name>一般用在特殊的情境下，比如：</name></p>
<p>在数据反序列化、转模型的过程中，服务器返回的字段如果以 init 开头，所以你需要定义一个 init 开头的属性，但默认生成的 setter 与 getter 方法也会以 init 开头，而编译器会把所有以 init 开头的方法当成初始化方法，而初始化方法只能返回 self 类型，因此编译器会报错。</p>
<p>这时你就可以使用下面的方式来避免编译器报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property(nonatomic, strong, getter=p_initBy, setter=setP_initBy:) NSString *initBy;</div></pre></td></tr></table></figure>
<p>另外也可以用关键字进行特殊说明，来避免编译器报错：</p>
<p>另外也可以用关键字进行特殊说明，来避免编译器报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@property(nonatomic, readwrite, copy, null_resettable) NSString *initBy;</div><div class="line"></div><div class="line">- (NSString *)initBy __attribute__((objc_method_family(none)));</div></pre></td></tr></table></figure>
<p>注意：很多人会认为如果属性具备 nonatomic 特质，则不使用 “同步锁”。其实在属性设置方法中使用的是自旋锁，自旋锁相关代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)</div><div class="line">&#123;</div><div class="line">   if (offset == 0) &#123;</div><div class="line">       object_setClass(self, newValue);</div><div class="line">       return;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   id oldValue;</div><div class="line">   id *slot = (id*) ((char*)self + offset);</div><div class="line"></div><div class="line">   if (copy) &#123;</div><div class="line">       newValue = [newValue copyWithZone:nil];</div><div class="line">   &#125; else if (mutableCopy) &#123;</div><div class="line">       newValue = [newValue mutableCopyWithZone:nil];</div><div class="line">   &#125; else &#123;</div><div class="line">       if (*slot == newValue) return;</div><div class="line">       newValue = objc_retain(newValue);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   if (!atomic) &#123;</div><div class="line">       oldValue = *slot;</div><div class="line">       *slot = newValue;</div><div class="line">   &#125; else &#123;</div><div class="line">       spinlock_t&amp; slotlock = PropertyLocks[slot];</div><div class="line">       slotlock.lock();</div><div class="line">       oldValue = *slot;</div><div class="line">       *slot = newValue;        </div><div class="line">       slotlock.unlock();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   objc_release(oldValue);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void objc_setProperty(id self, SEL _cmd, ptrdiff_t offset, id newValue, BOOL atomic, signed char shouldCopy) </div><div class="line">&#123;</div><div class="line">   bool copy = (shouldCopy &amp;&amp; shouldCopy != MUTABLE_COPY);</div><div class="line">   bool mutableCopy = (shouldCopy == MUTABLE_COPY);</div><div class="line">   reallySetProperty(self, _cmd, newValue, offset, atomic, copy, mutableCopy);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="weak属性需要在dealloc中置nil么？"><a href="#weak属性需要在dealloc中置nil么？" class="headerlink" title="weak属性需要在dealloc中置nil么？"></a>weak属性需要在dealloc中置nil么？</h2><p>不需要。</p>
<blockquote>
<p>在ARC环境无论是强指针还是弱指针都无需在 dealloc 设置为 nil ， ARC 会自动帮我们处理<br>即便是编译器不帮我们做这些，weak也不需要在 dealloc 中置nil：</p>
</blockquote>
<p>正如上文的：runtime 如何实现 weak 属性 中提到的：</p>
<p>我们模拟下 weak 的 setter 方法，应该如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)setObject:(NSObject *)object</div><div class="line">&#123;</div><div class="line">   objc_setAssociatedObject(self, &quot;object&quot;, object, OBJC_ASSOCIATION_ASSIGN);</div><div class="line">   [object cyl_runAtDealloc:^&#123;</div><div class="line">       _object = nil;</div><div class="line">   &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果对 cyl_runAtDealloc 的实现原理有兴趣，可以看下我写的一个小库，可以使用 CocoaPods 在项目中使用： <a href="https://github.com/ChenYilong/CYLDeallocBlockExecutor" target="_blank" rel="external">CYLDeallocBlockExecutor</a></p>
<p>也即:</p>
<blockquote>
<p>在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。</p>
</blockquote>
<h2 id="synthesize和-dynamic分别有什么作用？"><a href="#synthesize和-dynamic分别有什么作用？" class="headerlink" title="@synthesize和@dynamic分别有什么作用？"></a>@synthesize和@dynamic分别有什么作用？</h2><ol>
<li>@property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize和 @dynamic都没写，那么默认的就是@syntheszie var = _var;</li>
<li>@synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。</li>
<li>@dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。（当然对于 readonly 的属性只需提供 getter 即可）。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 instance.var = someVar，由于缺 setter 方法会导致程序崩溃；或者当运行到 someVar = var 时，由于缺 getter 方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。</li>
</ol>
<h2 id="ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？"><a href="#ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？" class="headerlink" title="ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？"></a>ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</h2><ol>
<li>对应基本数据类型默认关键字是</li>
</ol>
<p>atomic,readwrite,assign </p>
<ol>
<li>对于普通的 Objective-C 对象</li>
</ol>
<p>atomic,readwrite,strong</p>
<p>参考链接：</p>
<p><a href="https://stackoverflow.com/questions/8927727/objective-c-arc-strong-vs-retain-and-weak-vs-assign/15541801#15541801" target="_blank" rel="external">Objective-C ARC: strong vs retain and weak vs assign</a></p>
<p>Variable property attributes or Modifiers in iOS</p>
<h2 id="用-property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？"><a href="#用-property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？" class="headerlink" title="用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？"></a>用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</h2><ol>
<li>因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.</li>
<li>如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性.</li>
</ol>
<p>copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。 当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。</p>
<p>举例说明：</p>
<p>定义一个以 strong 修饰的 array：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic ,readwrite, strong) NSArray *array;</div></pre></td></tr></table></figure>
<p>然后进行下面的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">NSArray *array = @[ @1, @2, @3, @4 ];</div><div class="line">NSMutableArray *mutableArray = [NSMutableArray arrayWithArray:array];</div><div class="line"></div><div class="line">self.array = mutableArray;</div><div class="line">[mutableArray removeAllObjects];;</div><div class="line">NSLog(@&quot;%@&quot;,self.array);</div><div class="line"></div><div class="line">[mutableArray addObjectsFromArray:array];</div><div class="line">self.array = [mutableArray copy];</div><div class="line">[mutableArray removeAllObjects];;</div><div class="line">NSLog(@&quot;%@&quot;,self.array);</div></pre></td></tr></table></figure>
<p>打印结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">2015-09-27 19:10:32.523 CYLArrayCopyDmo[10681:713670] (</div><div class="line">)</div><div class="line">2015-09-27 19:10:32.524 CYLArrayCopyDmo[10681:713670] (</div><div class="line">   1,</div><div class="line">   2,</div><div class="line">   3,</div><div class="line">   4</div><div class="line">)</div></pre></td></tr></table></figure>
<p>为了理解这种做法，首先要知道，两种情况：</p>
<ol>
<li>对非集合类对象的 copy 与 mutableCopy 操作；</li>
<li>对集合类对象的 copy 与 mutableCopy 操作。</li>
</ol>
<h3 id="对非集合类对象的copy操作："><a href="#对非集合类对象的copy操作：" class="headerlink" title="对非集合类对象的copy操作："></a>对非集合类对象的copy操作：</h3><p>在非集合类对象中：对 immutable 对象进行 copy 操作，是指针复制，mutableCopy 操作时内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。用代码简单表示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[immutableObject copy] // 浅复制</div><div class="line">[immutableObject mutableCopy] //深复制</div><div class="line">[mutableObject copy] //深复制</div><div class="line">[mutableObject mutableCopy] //深复制</div></pre></td></tr></table></figure>
<p>比如以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSMutableString *string = [NSMutableString stringWithString:@&quot;origin&quot;];//copy</div><div class="line">NSString *stringCopy = [string copy];</div></pre></td></tr></table></figure>
<p>查看内存，会发现 string、stringCopy 内存地址都不一样，说明此时都是做内容拷贝、深拷贝。即使你进行如下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[string appendString:@&quot;origion!&quot;]</div></pre></td></tr></table></figure>
<p>stringCopy 的值也不会因此改变，但是如果不使用 copy，stringCopy 的值就会被改变。 集合类对象以此类推。 所以，</p>
<blockquote>
<p>用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p>
</blockquote>
<h3 id="集合类对象的copy与mutableCopy"><a href="#集合类对象的copy与mutableCopy" class="headerlink" title="集合类对象的copy与mutableCopy"></a>集合类对象的copy与mutableCopy</h3><p>集合类对象是指 NSArray、NSDictionary、NSSet … 之类的对象。下面先看集合类immutable对象使用 copy 和 mutableCopy 的一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSArray *array = @[@[@&quot;a&quot;, @&quot;b&quot;], @[@&quot;c&quot;, @&quot;d&quot;]];</div><div class="line">NSArray *copyArray = [array copy];</div><div class="line">NSMutableArray *mCopyArray = [array mutableCopy];</div></pre></td></tr></table></figure>
<p>查看内容，可以看到 copyArray 和 array 的地址是一样的，而 mCopyArray 和 array 的地址是不同的。说明 copy 操作进行了指针拷贝，mutableCopy 进行了内容拷贝。但需要强调的是：此处的内容拷贝，仅仅是拷贝 array 这个对象，array 集合内部的元素仍然是指针拷贝。这和上面的非集合 immutable 对象的拷贝还是挺相似的，那么mutable对象的拷贝会不会类似呢？我们继续往下，看 mutable 对象拷贝的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *array = [NSMutableArray arrayWithObjects:[NSMutableString stringWithString:@&quot;a&quot;],@&quot;b&quot;,@&quot;c&quot;,nil];</div><div class="line">NSArray *copyArray = [array copy];</div><div class="line">NSMutableArray *mCopyArray = [array mutableCopy];</div></pre></td></tr></table></figure>
<p>查看内存，如我们所料，copyArray、mCopyArray和 array 的内存地址都不一样，说明 copyArray、mCopyArray 都对 array 进行了内容拷贝。同样，我们可以得出结论：</p>
<p>在集合类对象中，对 immutable 对象进行 copy，是指针复制， mutableCopy 是内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制。用代码简单表示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[immutableObject copy] // 浅复制</div><div class="line">[immutableObject mutableCopy] //单层深复制</div><div class="line">[mutableObject copy] //单层深复制</div><div class="line">[mutableObject mutableCopy] //单层深复制</div></pre></td></tr></table></figure>
<p>这个代码结论和非集合类的非常相似。</p>
<p>参考链接：<a href="https://www.zybuluo.com/MicroCai/note/50592" target="_blank" rel="external">iOS 集合的深复制与浅复制</a></p>
<h2 id="objc中向一个nil对象发送消息将会发生什么？"><a href="#objc中向一个nil对象发送消息将会发生什么？" class="headerlink" title="objc中向一个nil对象发送消息将会发生什么？"></a>objc中向一个nil对象发送消息将会发生什么？</h2><p>在 Objective-C 中向 nil 发送消息是完全有效的——只是在运行时不会有任何作用:</p>
<ol>
<li>如果一个方法返回值是一个对象，那么发送给nil的消息将返回0(nil)。例如：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Person * motherInlaw = [[aPerson spouse] mother];</div></pre></td></tr></table></figure>
<p>如果 spouse 对象为 nil，那么发送给 nil 的消息 mother 也将返回 nil。 </p>
<ol>
<li><p>如果方法返回值为指针类型，其指针大小为小于或者等于sizeof(void*)，float，double，long double 或者 long long 的整型标量，发送给 nil 的消息将返回0。 </p>
</li>
<li><p>如果方法返回值为结构体,发送给 nil 的消息将返回0。结构体中各个字段的值将都是0。 </p>
</li>
<li><p>如果方法的返回值不是上述提到的几种情况，那么发送给 nil 的消息的返回值将是未定义的。</p>
</li>
</ol>
<p>具体原因如下：</p>
<blockquote>
<p>objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。</p>
</blockquote>
<p>那么，为了方便理解这个内容，还是贴一个objc的源代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// runtime.h（类在runtime中的定义）</div><div class="line">// http://weibo.com/luohanchenyilong/</div><div class="line">// https://github.com/ChenYilong</div><div class="line"></div><div class="line">struct objc_class &#123;</div><div class="line">  Class isa OBJC_ISA_AVAILABILITY; //isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，runtime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object</div><div class="line">  #if !__OBJC2__</div><div class="line">  Class super_class OBJC2_UNAVAILABLE; // 父类</div><div class="line">  const char *name OBJC2_UNAVAILABLE; // 类名</div><div class="line">  long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为0</div><div class="line">  long info OBJC2_UNAVAILABLE; // 类信息，供运行期使用的一些位标识</div><div class="line">  long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小</div><div class="line">  struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; // 该类的成员变量链表</div><div class="line">  struct objc_method_list **methodLists OBJC2_UNAVAILABLE; // 方法定义的链表</div><div class="line">  struct objc_cache *cache OBJC2_UNAVAILABLE; // 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在method Lists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。</div><div class="line">  struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 协议链表</div><div class="line">  #endif</div><div class="line">  &#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure>
<p>objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，然后在发送消息的时候，objc_msgSend方法不会返回值，所谓的返回内容都是具体调用时执行的。 那么，回到本题，如果向一个nil对象发送消息，首先在寻找对象的isa指针时就是0地址返回了，所以不会出现任何错误。</p>
<h2 id="objc中向一个对象发送消息-obj-foo-和objc-msgSend-函数之间有什么关系？"><a href="#objc中向一个对象发送消息-obj-foo-和objc-msgSend-函数之间有什么关系？" class="headerlink" title="objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？"></a>objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？</h2><p>具体原因同上题：该方法编译之后就是objc_msgSend()函数调用.</p>
<p>我们用 clang 分析下，clang 提供一个命令，可以将Objective-C的源码改写成C++语言，借此可以研究下[obj foo]和objc_msgSend()函数之间有什么关系。</p>
<p>以下面的代码为例，由于 clang 后的代码达到了10万多行，为了便于区分，添加了一个叫 iOSinit 方法，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  main.m</div><div class="line">//  http://weibo.com/luohanchenyilong/</div><div class="line">//  https://github.com/ChenYilong</div><div class="line">//  Copyright (c) 2015年 微博@iOS程序犭袁. All rights reserved.</div><div class="line">//</div><div class="line"></div><div class="line"></div><div class="line">#import &quot;CYLTest.h&quot;</div><div class="line"></div><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        CYLTest *test = [[CYLTest alloc] init];</div><div class="line">        [test performSelector:(@selector(iOSinit))];</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在终端中输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -rewrite-objc main.m</div></pre></td></tr></table></figure>
<p>就可以生成一个main.cpp的文件，在最低端（10万4千行左右）</p>
<p><img src="https://camo.githubusercontent.com/bf346edc21ab4b3387906602249b357d250ab1c2/687474703a2f2f692e696d6775722e636f6d2f6541483559576e2e706e67" alt=""></p>
<p>我们可以看到大概是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">((void ()(id, SEL))(void )objc_msgSend)((id)obj, sel_registerName(&quot;foo&quot;));</div></pre></td></tr></table></figure>
<p>也就是说：</p>
<blockquote>
<p>[obj foo];在objc编译时，会被转意为：objc_msgSend(obj, @selector(foo));。</p>
</blockquote>
<h2 id="runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）"><a href="#runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）" class="headerlink" title="runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）"></a>runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）</h2><p>每一个类对象中都一个方法列表,方法列表中记录着方法的名称,方法实现,以及参数类型,其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现.</p>
<h2 id="objc中的类方法和实例方法有什么本质区别和联系？"><a href="#objc中的类方法和实例方法有什么本质区别和联系？" class="headerlink" title="objc中的类方法和实例方法有什么本质区别和联系？"></a>objc中的类方法和实例方法有什么本质区别和联系？</h2><p>类方法：</p>
<ol>
<li>类方法是属于类对象的</li>
<li>类方法只能通过类对象调用</li>
<li>类方法中的self是类对象</li>
<li>类方法可以调用其他的类方法</li>
<li>类方法中不能访问成员变量</li>
<li>类方法中不能直接调用对象方法</li>
</ol>
<p>实例方法：</p>
<ol>
<li>实例方法是属于实例对象的</li>
<li>实例方法只能通过实例对象调用</li>
<li>实例方法中的self是实例对象</li>
<li>实例方法中可以访问成员变量</li>
<li>实例方法中直接调用实例方法</li>
<li>实例方法中也可以调用类方法(通过类名)</li>
</ol>
<p><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md" target="_blank" rel="external">参考文档</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/10/09/面试  (八) - 高级面试题/" rel="next" title="面试题8：高级面试题">
                <i class="fa fa-chevron-left"></i> 面试题8：高级面试题
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/10/17/GitHub面试搜索2/" rel="prev" title="GitHub面试搜索2">
                GitHub面试搜索2 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么情况使用-weak-关键字，相比-assign-有什么不同？"><span class="nav-number">1.</span> <span class="nav-text">什么情况使用 weak 关键字，相比 assign 有什么不同？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#怎么用-copy-关键字？"><span class="nav-number">2.</span> <span class="nav-text">怎么用 copy 关键字？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#这个写法会出什么问题：-property-copy-NSMutableArray-array"><span class="nav-number">3.</span> <span class="nav-text">这个写法会出什么问题： @property (copy) NSMutableArray *array;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何让自己的类用-copy-修饰符？如何重写带-copy-关键字的-setter？"><span class="nav-number">4.</span> <span class="nav-text">如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的"><span class="nav-number">5.</span> <span class="nav-text">@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#protocol-和-category-中如何使用-property"><span class="nav-number">6.</span> <span class="nav-text">@protocol 和 category 中如何使用 @property</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#runtime-如何实现-weak-属性"><span class="nav-number">7.</span> <span class="nav-text">runtime 如何实现 weak 属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#property中有哪些属性关键字？-property-后面可以有哪些修饰符？"><span class="nav-number">8.</span> <span class="nav-text">@property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#weak属性需要在dealloc中置nil么？"><span class="nav-number">9.</span> <span class="nav-text">weak属性需要在dealloc中置nil么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synthesize和-dynamic分别有什么作用？"><span class="nav-number">10.</span> <span class="nav-text">@synthesize和@dynamic分别有什么作用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？"><span class="nav-number">11.</span> <span class="nav-text">ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用-property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？"><span class="nav-number">12.</span> <span class="nav-text">用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对非集合类对象的copy操作："><span class="nav-number">12.1.</span> <span class="nav-text">对非集合类对象的copy操作：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合类对象的copy与mutableCopy"><span class="nav-number">12.2.</span> <span class="nav-text">集合类对象的copy与mutableCopy</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#objc中向一个nil对象发送消息将会发生什么？"><span class="nav-number">13.</span> <span class="nav-text">objc中向一个nil对象发送消息将会发生什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#objc中向一个对象发送消息-obj-foo-和objc-msgSend-函数之间有什么关系？"><span class="nav-number">14.</span> <span class="nav-text">objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）"><span class="nav-number">15.</span> <span class="nav-text">runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#objc中的类方法和实例方法有什么本质区别和联系？"><span class="nav-number">16.</span> <span class="nav-text">objc中的类方法和实例方法有什么本质区别和联系？</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>



        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
